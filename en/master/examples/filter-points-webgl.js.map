{"version":3,"sources":["webpack:///./filter-points-webgl.js"],"names":["__webpack_require__","r","__webpack_exports__","_src_ol_Map_js__WEBPACK_IMPORTED_MODULE_0__","_src_ol_View_js__WEBPACK_IMPORTED_MODULE_1__","_src_ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_2__","_src_ol_Feature__WEBPACK_IMPORTED_MODULE_3__","_src_ol_geom_Point__WEBPACK_IMPORTED_MODULE_4__","_src_ol_layer_Vector__WEBPACK_IMPORTED_MODULE_5__","_src_ol_source__WEBPACK_IMPORTED_MODULE_6__","_src_ol_proj__WEBPACK_IMPORTED_MODULE_7__","_src_ol_renderer_webgl_PointsLayer__WEBPACK_IMPORTED_MODULE_8__","_src_ol_math__WEBPACK_IMPORTED_MODULE_9__","_src_ol_source_Stamen__WEBPACK_IMPORTED_MODULE_10__","vectorSource","features","attributions","oldColor","newColor","startTime","Date","now","minYearInput","document","getElementById","maxYearInput","updateStatusText","const","div","querySelector","textContent","value","addEventListener","client","WebglPointsLayer","VectorLayer","createRenderer","this","colorCallback","feature","color","ratio","Object","get","sizeCallback","fragmentShader","join","opacityCallback","uniforms","u_time","u_minYear","parseInt","u_maxYear","XMLHttpRequest","open","onload","curIndex","csv","responseText","prevIndex","indexOf","line","substr","split","coords","parseFloat","isNaN","push","mass","year","geometry","addFeatures","send","map","layers","source","layer","target","view","center","zoom","animate","render","window","requestAnimationFrame"],"mappings":"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","file":"filter-points-webgl.js","sourcesContent":["import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport Feature from '../src/ol/Feature';\nimport Point from '../src/ol/geom/Point';\nimport VectorLayer from '../src/ol/layer/Vector';\nimport {Vector} from '../src/ol/source';\nimport {fromLonLat} from '../src/ol/proj';\nimport WebGLPointsLayerRenderer from '../src/ol/renderer/webgl/PointsLayer';\nimport {clamp, lerp} from '../src/ol/math';\nimport Stamen from '../src/ol/source/Stamen';\n\nconst vectorSource = new Vector({\n  features: [],\n  attributions: 'NASA'\n});\n\nconst oldColor = [180, 140, 140];\nconst newColor = [255, 80, 80];\n\nconst startTime = Date.now() * 0.001;\n\n// hanle input values & events\nconst minYearInput = document.getElementById('min-year');\nconst maxYearInput = document.getElementById('max-year');\nfunction updateStatusText() {\n  const div = document.getElementById('status');\n  div.querySelector('span.min-year').textContent = minYearInput.value;\n  div.querySelector('span.max-year').textContent = maxYearInput.value;\n}\nminYearInput.addEventListener('input', updateStatusText);\nminYearInput.addEventListener('change', updateStatusText);\nmaxYearInput.addEventListener('input', updateStatusText);\nmaxYearInput.addEventListener('change', updateStatusText);\nupdateStatusText();\n\nclass WebglPointsLayer extends VectorLayer {\n  createRenderer() {\n    return new WebGLPointsLayerRenderer(this, {\n      colorCallback: function(feature, color) {\n        // color is interpolated based on year\n        const ratio = clamp((feature.get('year') - 1800) / (2013 - 1800), 0, 1);\n\n        color[0] = lerp(oldColor[0], newColor[0], ratio) / 255;\n        color[1] = lerp(oldColor[1], newColor[1], ratio) / 255;\n        color[2] = lerp(oldColor[2], newColor[2], ratio) / 255;\n        color[3] = 1;\n\n        return color;\n      },\n      sizeCallback: function(feature) {\n        return 18 * clamp(feature.get('mass') / 200000, 0, 1) + 8;\n      },\n      fragmentShader: [\n        'precision mediump float;',\n\n        'uniform float u_time;',\n        'uniform float u_minYear;',\n        'uniform float u_maxYear;',\n\n        'varying vec2 v_texCoord;',\n        'varying float v_opacity;',\n        'varying vec4 v_color;',\n\n        'void main(void) {',\n        '  float impactYear = v_opacity;',\n\n        // filter out pixels if the year is outside of the given range\n        '  if (impactYear < u_minYear || v_opacity > u_maxYear) {',\n        '    discard;',\n        '  }',\n\n        '  vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);',\n        '  float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;',\n        '  float value = 2.0 * (1.0 - sqRadius);',\n        '  float alpha = smoothstep(0.0, 1.0, value);',\n\n        '  vec3 color = v_color.rgb;',\n        '  float period = 8.0;',\n        '  color.g *= 2.0 * (1.0 - sqrt(mod(u_time + impactYear * 0.025, period) / period));',\n\n        '  gl_FragColor = vec4(color, v_color.a);',\n        '  gl_FragColor.a *= alpha;',\n        '  gl_FragColor.rgb *= gl_FragColor.a;',\n        '}'\n      ].join(' '),\n      opacityCallback: function(feature) {\n        // here the opacity channel of the vertices is used to store the year of impact\n        return feature.get('year');\n      },\n      uniforms: {\n        u_time: function() {\n          return Date.now() * 0.001 - startTime;\n        },\n        u_minYear: function() {\n          return parseInt(minYearInput.value);\n        },\n        u_maxYear: function() {\n          return parseInt(maxYearInput.value);\n        }\n      }\n    });\n  }\n}\n\n\nfunction loadData() {\n  const client = new XMLHttpRequest();\n  client.open('GET', 'data/csv/meteorite_landings.csv');\n  client.onload = function() {\n    const csv = client.responseText;\n    const features = [];\n\n    let prevIndex = csv.indexOf('\\n') + 1; // scan past the header line\n\n    let curIndex;\n    while ((curIndex = csv.indexOf('\\n', prevIndex)) != -1) {\n      const line = csv.substr(prevIndex, curIndex - prevIndex).split(',');\n      prevIndex = curIndex + 1;\n\n      const coords = fromLonLat([parseFloat(line[4]), parseFloat(line[3])]);\n      if (isNaN(coords[0]) || isNaN(coords[1])) {\n        // guard against bad data\n        continue;\n      }\n\n      features.push(new Feature({\n        mass: parseFloat(line[1]) || 0,\n        year: parseInt(line[2]) || 0,\n        geometry: new Point(coords)\n      }));\n    }\n\n    vectorSource.addFeatures(features);\n  };\n  client.send();\n}\n\nloadData();\n\nconst map = new Map({\n  layers: [\n    new TileLayer({\n      source: new Stamen({\n        layer: 'toner'\n      })\n    }),\n    new WebglPointsLayer({\n      source: vectorSource\n    })\n  ],\n  target: document.getElementById('map'),\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\n// animate the map\nfunction animate() {\n  map.render();\n  window.requestAnimationFrame(animate);\n}\nanimate();\n"],"sourceRoot":""}