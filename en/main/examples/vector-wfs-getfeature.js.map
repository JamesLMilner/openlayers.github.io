{"version":3,"file":"vector-wfs-getfeature.js","mappings":"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","sources":["webpack:///../src/ol/format/GML3.js","webpack:///../src/ol/format/GML32.js","webpack:///../src/ol/format/filter/Filter.js","webpack:///../src/ol/format/filter/And.js","webpack:///../src/ol/format/filter/LogicalNary.js","webpack:///../src/ol/format/filter/Bbox.js","webpack:///../src/ol/format/filter/Comparison.js","webpack:///../src/ol/format/filter/EqualTo.js","webpack:///../src/ol/format/filter/ComparisonBinary.js","webpack:///../src/ol/format/filter/IsLike.js","webpack:///../src/ol/format/filter.js","webpack:///../src/ol/format/WFS.js","webpack:///./vector-wfs-getfeature.js"],"sourcesContent":["/**\n * @module ol/format/GML3\n */\nimport GML2 from './GML2.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Polygon from '../geom/Polygon.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  getAllTextContent,\n  makeArrayExtender,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n  makeSimpleNodeFactory,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {assign} from '../obj.js';\nimport {createOrUpdate} from '../extent.js';\nimport {extend} from '../array.js';\nimport {get as getProjection} from '../proj.js';\nimport {readNonNegativeIntegerString, writeStringTextNode} from './xsd.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\n\n/**\n * @const\n * @type {string}\n * @private\n */\nconst schemaLocation =\n  GMLNS +\n  ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' +\n  '1.0.0/gmlsf.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember',\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format\n * version 3.1.1.\n * Currently only supports GML 3.1.1 Simple Features profile.\n *\n * @api\n */\nclass GML3 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [opt_options] Optional configuration object.\n   */\n  constructor(opt_options) {\n    const options =\n      /** @type {import(\"./GMLBase.js\").Options} */\n      (opt_options ? opt_options : {});\n\n    super(options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.surface_ = options.surface !== undefined ? options.surface : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.curve_ = options.curve !== undefined ? options.curve : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiCurve_ =\n      options.multiCurve !== undefined ? options.multiCurve : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiSurface_ =\n      options.multiSurface !== undefined ? options.multiSurface : true;\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : schemaLocation;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hasZ = options.hasZ !== undefined ? options.hasZ : false;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiCurve(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTICURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (lineStrings) {\n      const multiLineString = new MultiLineString(lineStrings);\n      return multiLineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Polygon.\n   */\n  readFlatCurveRing(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTICURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    const flatCoordinates = [];\n    for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n      extend(flatCoordinates, lineStrings[i].getFlatCoordinates());\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiSurface(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTISURFACE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  curveMemberParser(node, objectStack) {\n    parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  surfaceMemberParser(node, objectStack) {\n    parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.PATCHES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readSegment(node, objectStack) {\n    return pushParseAndPop([], this.SEGMENTS_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPolygonPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readLineStringSegment(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  interiorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  exteriorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readSurface(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.SURFACE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, GeometryLayout.XYZ, ends);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readCurve(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.CURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, GeometryLayout.XYZ);\n      return lineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readEnvelope(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.ENVELOPE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    return createOrUpdate(\n      flatCoordinates[1][0],\n      flatCoordinates[1][1],\n      flatCoordinates[2][0],\n      flatCoordinates[2][1]\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPos(node, objectStack) {\n    let s = getAllTextContent(node, false);\n    const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n    /** @type {Array<number>} */\n    const flatCoordinates = [];\n    let m;\n    while ((m = re.exec(s))) {\n      flatCoordinates.push(parseFloat(m[1]));\n      s = s.substr(m[0].length);\n    }\n    if (s !== '') {\n      return undefined;\n    }\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    if (axisOrientation === 'neu') {\n      let i, ii;\n      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n        const y = flatCoordinates[i];\n        const x = flatCoordinates[i + 1];\n        flatCoordinates[i] = x;\n        flatCoordinates[i + 1] = y;\n      }\n    }\n    const len = flatCoordinates.length;\n    if (len == 2) {\n      flatCoordinates.push(0);\n    }\n    if (len === 0) {\n      return undefined;\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPosList(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    const contextDimension = context['srsDimension'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    const coords = s.split(/\\s+/);\n    // The \"dimension\" attribute is from the GML 3.0.1 spec.\n    let dim = 2;\n    if (node.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('srsDimension'));\n    } else if (node.getAttribute('dimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('dimension'));\n    } else if (\n      /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\n    ) {\n      dim = readNonNegativeIntegerString(\n        /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\n      );\n    } else if (contextDimension) {\n      dim = readNonNegativeIntegerString(contextDimension);\n    }\n    let x, y, z;\n    const flatCoordinates = [];\n    for (let i = 0, ii = coords.length; i < ii; i += dim) {\n      x = parseFloat(coords[i]);\n      y = parseFloat(coords[i + 1]);\n      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} value Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePos_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    const point = value.getCoordinates();\n    let coords;\n    // only 2d for simple features profile\n    if (axisOrientation.substr(0, 2) === 'en') {\n      coords = point[0] + ' ' + point[1];\n    } else {\n      coords = point[1] + ' ' + point[0];\n    }\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n    writeStringTextNode(node, coords);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [opt_srsName] Optional srsName\n   * @param {boolean} [opt_hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, opt_srsName, opt_hasZ) {\n    let axisOrientation = 'enu';\n    if (opt_srsName) {\n      axisOrientation = getProjection(opt_srsName).getAxisOrientation();\n    }\n    let coords =\n      axisOrientation.substr(0, 2) === 'en'\n        ? point[0] + ' ' + point[1]\n        : point[1] + ' ' + point[0];\n    if (opt_hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePosList_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    let point;\n    for (let i = 0; i < len; ++i) {\n      point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const pos = createElementNS(node.namespaceURI, 'pos');\n    node.appendChild(pos);\n    this.writePos_(pos, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}),\n      this.ENVELOPE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack,\n      keys,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const posList = createElementNS(node.namespaceURI, 'posList');\n    node.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [opt_nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, opt_nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(\n      parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'interior' : 'exterior'\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS,\n        this.RING_NODE_FACTORY_,\n        rings,\n        objectStack,\n        undefined,\n        this\n      );\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (\n      node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment'\n    ) {\n      const posList = createElementNS(node.namespaceURI, 'posList');\n      node.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiPolygon} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      polygons,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    const hasZ = context['hasZ'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS,\n      makeSimpleNodeFactory('pointMember'),\n      points,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiLineString} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      lines,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const item = assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\n        context\n      );\n    } else {\n      value = transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\n        true,\n        context\n      );\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      this.GEOMETRY_SERIALIZERS,\n      this.GEOMETRY_NODE_FACTORY_,\n      [value],\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null) {\n          keys.push(key);\n          values.push(value);\n          if (\n            key == geometryName ||\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\n              'function'\n          ) {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                this.writeGeometryElement,\n                this\n              );\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] =\n                makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack,\n      keys\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeFeatureMembers_(node, features, objectStack) {\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureType = context['featureType'];\n    const featureNS = context['featureNS'];\n    /** @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>} */\n    const serializers = {};\n    serializers[featureNS] = {};\n    serializers[featureNS][featureType] = makeChildAppender(\n      this.writeFeatureElement,\n      this\n    );\n    const item = assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      serializers,\n      makeSimpleNodeFactory(featureType, featureNS),\n      features,\n      objectStack\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [opt_nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, opt_nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      this.namespace,\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [opt_nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, opt_nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const curve = context['curve'];\n    const multiCurve = context['multiCurve'];\n    let nodeName;\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (\n        value\n      ).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'LineString' && curve === true) {\n        nodeName = 'Curve';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS(this.namespace, nodeName);\n  }\n\n  /**\n   * Encode a geometry in GML 3.1.1 Simple Features.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeGeometryNode(geometry, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    const geom = createElementNS(this.namespace, 'geom');\n    const context = {\n      node: geom,\n      hasZ: this.hasZ,\n      srsName: this.srsName,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n    };\n    if (opt_options) {\n      assign(context, opt_options);\n    }\n    this.writeGeometryElement(geom, geometry, [context]);\n    return geom;\n  }\n\n  /**\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Options.\n   * @return {Element} Node.\n   * @api\n   */\n  writeFeaturesNode(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    const node = createElementNS(this.namespace, 'featureMembers');\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      this.schemaLocation\n    );\n    const context = {\n      srsName: this.srsName,\n      hasZ: this.hasZ,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n      featureNS: this.featureNS,\n      featureType: this.featureType,\n    };\n    if (opt_options) {\n      assign(context, opt_options);\n    }\n    this.writeFeatureMembers_(node, features, [context]);\n    return node;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'interior': GML3.prototype.interiorParser,\n    'exterior': GML3.prototype.exteriorParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML3.prototype.readSurface),\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\n    'Curve': makeReplacer(GML3.prototype.readCurve),\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTICURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTISURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'patches': makeReplacer(GML3.prototype.readPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'segments': makeReplacer(GML3.prototype.readSegment),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.ENVELOPE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.PATCHES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SEGMENTS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineStringSegment': makeArrayExtender(\n      GML3.prototype.readLineStringSegment\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n    'Ring': makeReplacer(GML3.prototype.readFlatCurveRing),\n  },\n};\n\n/**\n * Encode an array of features in GML 3.1.1 Simple Features.\n *\n * @function\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Options.\n * @return {string} Result.\n * @api\n */\nGML3.prototype.writeFeatures;\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\n    'interior': makeChildAppender(GML3.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n    'polygonMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n    'curveMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML3.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString\n    ),\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope),\n  },\n};\n\nexport default GML3;\n","/**\n * @module ol/format/GML32\n */\nimport GML2 from './GML2.js';\nimport GML3 from './GML3.js';\nimport GMLBase from './GMLBase.js';\nimport {\n  makeArrayExtender,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n} from '../xml.js';\nimport {writeStringTextNode} from '../format/xsd.js';\n\n/**\n * @classdesc Feature format for reading and writing data in the GML format\n *            version 3.2.1.\n * @api\n */\nclass GML32 extends GML3 {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [opt_options] Optional configuration object.\n   */\n  constructor(opt_options) {\n    const options = /** @type {import(\"./GMLBase.js\").Options} */ (\n      opt_options ? opt_options : {}\n    );\n\n    super(options);\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : this.namespace + ' http://schemas.opengis.net/gml/3.2.1/gml.xsd';\n  }\n}\n\nGML32.prototype.namespace = 'http://www.opengis.net/gml/3.2';\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'interior': GML3.prototype.interiorParser,\n    'exterior': GML3.prototype.exteriorParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML32.prototype.readSurface),\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\n    'Curve': makeReplacer(GML32.prototype.readCurve),\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\n    'Envelope': makeReplacer(GML32.prototype.readEnvelope),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTICURVE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTISURFACE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.CURVEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.SURFACEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.SURFACE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'patches': makeReplacer(GML3.prototype.readPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.CURVE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'segments': makeReplacer(GML3.prototype.readSegment),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.ENVELOPE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.PATCHES_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.SEGMENTS_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'LineStringSegment': makeArrayExtender(\n      GML3.prototype.readLineStringSegment\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTIPOINT_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTILINESTRING_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'lineStringMember': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser\n    ),\n    'lineStringMembers': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTIPOLYGON_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.POINTMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.LINESTRINGMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.POLYGONMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n    'Ring': makeReplacer(GML32.prototype.readFlatCurveRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\n    'interior': makeChildAppender(GML3.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'surfaceMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n    'polygonMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'lineStringMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n    'curveMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML32.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString\n    ),\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope),\n  },\n};\n\nexport default GML32;\n","/**\n * @module ol/format/filter/Filter\n */\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature filters.\n *\n * @abstract\n */\nclass Filter {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   */\n  constructor(tagName) {\n    /**\n     * @private\n     * @type {!string}\n     */\n    this.tagName_ = tagName;\n  }\n\n  /**\n   * The XML tag name for a filter.\n   * @return {!string} Name.\n   */\n  getTagName() {\n    return this.tagName_;\n  }\n}\n\nexport default Filter;\n","/**\n * @module ol/format/filter/And\n */\nimport LogicalNary from './LogicalNary.js';\n\n/**\n * @classdesc\n * Represents a logical `<And>` operator between two or more filter conditions.\n *\n * @abstract\n */\nclass And extends LogicalNary {\n  /**\n   * @param {...import(\"./Filter.js\").default} conditions Conditions.\n   */\n  constructor(conditions) {\n    super('And', Array.prototype.slice.call(arguments));\n  }\n}\n\nexport default And;\n","/**\n * @module ol/format/filter/LogicalNary\n */\nimport Filter from './Filter.js';\nimport {assert} from '../../asserts.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature n-ary logical filters.\n *\n * @abstract\n */\nclass LogicalNary extends Filter {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {Array<import(\"./Filter.js\").default>} conditions Conditions.\n   */\n  constructor(tagName, conditions) {\n    super(tagName);\n\n    /**\n     * @type {Array<import(\"./Filter.js\").default>}\n     */\n    this.conditions = conditions;\n    assert(this.conditions.length >= 2, 57); // At least 2 conditions are required.\n  }\n}\n\nexport default LogicalNary;\n","/**\n * @module ol/format/filter/Bbox\n */\nimport Filter from './Filter.js';\n\n/**\n * @classdesc\n * Represents a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @api\n */\nclass Bbox extends Filter {\n  /**\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!import(\"../../extent.js\").Extent} extent Extent.\n   * @param {string} [opt_srsName] SRS name. No srsName attribute will be set\n   * on geometries when this is not provided.\n   */\n  constructor(geometryName, extent, opt_srsName) {\n    super('BBOX');\n\n    /**\n     * @type {!string}\n     */\n    this.geometryName = geometryName;\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.extent = extent;\n    if (extent.length !== 4) {\n      throw new Error(\n        'Expected an extent with four values ([minX, minY, maxX, maxY])'\n      );\n    }\n\n    /**\n     * @type {string|undefined}\n     */\n    this.srsName = opt_srsName;\n  }\n}\n\nexport default Bbox;\n","/**\n * @module ol/format/filter/Comparison\n */\nimport Filter from './Filter.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature property comparison filters.\n *\n * @abstract\n */\nclass Comparison extends Filter {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} propertyName Name of the context property to compare.\n   */\n  constructor(tagName, propertyName) {\n    super(tagName);\n\n    /**\n     * @type {!string}\n     */\n    this.propertyName = propertyName;\n  }\n}\n\nexport default Comparison;\n","/**\n * @module ol/format/filter/EqualTo\n */\nimport ComparisonBinary from './ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsEqualTo>` comparison operator.\n * @api\n */\nclass EqualTo extends ComparisonBinary {\n  /**\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean} [opt_matchCase] Case-sensitive?\n   */\n  constructor(propertyName, expression, opt_matchCase) {\n    super('PropertyIsEqualTo', propertyName, expression, opt_matchCase);\n  }\n}\n\nexport default EqualTo;\n","/**\n * @module ol/format/filter/ComparisonBinary\n */\nimport Comparison from './Comparison.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature property binary comparison filters.\n *\n * @abstract\n */\nclass ComparisonBinary extends Comparison {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean} [opt_matchCase] Case-sensitive?\n   */\n  constructor(tagName, propertyName, expression, opt_matchCase) {\n    super(tagName, propertyName);\n\n    /**\n     * @type {!(string|number)}\n     */\n    this.expression = expression;\n\n    /**\n     * @type {boolean|undefined}\n     */\n    this.matchCase = opt_matchCase;\n  }\n}\n\nexport default ComparisonBinary;\n","/**\n * @module ol/format/filter/IsLike\n */\nimport Comparison from './Comparison.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsLike>` comparison operator.\n * @api\n */\nclass IsLike extends Comparison {\n  /**\n   * [constructor description]\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!string} pattern Text pattern.\n   * @param {string} [opt_wildCard] Pattern character which matches any sequence of\n   *    zero or more string characters. Default is '*'.\n   * @param {string} [opt_singleChar] pattern character which matches any single\n   *    string character. Default is '.'.\n   * @param {string} [opt_escapeChar] Escape character which can be used to escape\n   *    the pattern characters. Default is '!'.\n   * @param {boolean} [opt_matchCase] Case-sensitive?\n   */\n  constructor(\n    propertyName,\n    pattern,\n    opt_wildCard,\n    opt_singleChar,\n    opt_escapeChar,\n    opt_matchCase\n  ) {\n    super('PropertyIsLike', propertyName);\n\n    /**\n     * @type {!string}\n     */\n    this.pattern = pattern;\n\n    /**\n     * @type {!string}\n     */\n    this.wildCard = opt_wildCard !== undefined ? opt_wildCard : '*';\n\n    /**\n     * @type {!string}\n     */\n    this.singleChar = opt_singleChar !== undefined ? opt_singleChar : '.';\n\n    /**\n     * @type {!string}\n     */\n    this.escapeChar = opt_escapeChar !== undefined ? opt_escapeChar : '!';\n\n    /**\n     * @type {boolean|undefined}\n     */\n    this.matchCase = opt_matchCase;\n  }\n}\n\nexport default IsLike;\n","/**\n * @module ol/format/filter\n */\nimport And from './filter/And.js';\nimport Bbox from './filter/Bbox.js';\nimport Contains from './filter/Contains.js';\nimport DWithin from './filter/DWithin.js';\nimport Disjoint from './filter/Disjoint.js';\nimport During from './filter/During.js';\nimport EqualTo from './filter/EqualTo.js';\nimport GreaterThan from './filter/GreaterThan.js';\nimport GreaterThanOrEqualTo from './filter/GreaterThanOrEqualTo.js';\nimport Intersects from './filter/Intersects.js';\nimport IsBetween from './filter/IsBetween.js';\nimport IsLike from './filter/IsLike.js';\nimport IsNull from './filter/IsNull.js';\nimport LessThan from './filter/LessThan.js';\nimport LessThanOrEqualTo from './filter/LessThanOrEqualTo.js';\nimport Not from './filter/Not.js';\nimport NotEqualTo from './filter/NotEqualTo.js';\nimport Or from './filter/Or.js';\nimport ResourceId from './filter/ResourceId.js';\nimport Within from './filter/Within.js';\n\n/**\n * Create a logical `<And>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @return {!And} `<And>` operator.\n * @api\n */\nexport function and(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(And, params))();\n}\n\n/**\n * Create a logical `<Or>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @return {!Or} `<Or>` operator.\n * @api\n */\nexport function or(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(Or, params))();\n}\n\n/**\n * Represents a logical `<Not>` operator for a filter condition.\n *\n * @param {!import(\"./filter/Filter.js\").default} condition Filter condition.\n * @return {!Not} `<Not>` operator.\n * @api\n */\nexport function not(condition) {\n  return new Not(condition);\n}\n\n/**\n * Create a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../extent.js\").Extent} extent Extent.\n * @param {string} [opt_srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Bbox} `<BBOX>` operator.\n * @api\n */\nexport function bbox(geometryName, extent, opt_srsName) {\n  return new Bbox(geometryName, extent, opt_srsName);\n}\n\n/**\n * Create a `<Contains>` operator to test whether a geometry-valued property\n * contains a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string} [opt_srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Contains} `<Contains>` operator.\n * @api\n */\nexport function contains(geometryName, geometry, opt_srsName) {\n  return new Contains(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Intersects>` operator to test whether a geometry-valued property\n * intersects a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string} [opt_srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Intersects} `<Intersects>` operator.\n * @api\n */\nexport function intersects(geometryName, geometry, opt_srsName) {\n  return new Intersects(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Disjoint>` operator to test whether a geometry-valued property\n * is disjoint to a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string} [opt_srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Disjoint} `<Disjoint>` operator.\n * @api\n */\nexport function disjoint(geometryName, geometry, opt_srsName) {\n  return new Disjoint(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Within>` operator to test whether a geometry-valued property\n * is within a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string} [opt_srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Within} `<Within>` operator.\n * @api\n */\nexport function within(geometryName, geometry, opt_srsName) {\n  return new Within(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<DWithin>` operator to test whether a geometry-valued property\n * is within a distance to a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {!number} distance Distance.\n * @param {!string} unit Unit.\n * @param {string} [opt_srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!DWithin} `<DWithin>` operator.\n * @api\n */\nexport function dwithin(geometryName, geometry, distance, unit, opt_srsName) {\n  return new DWithin(geometryName, geometry, distance, unit, opt_srsName);\n}\n\n/**\n * Creates a `<PropertyIsEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean} [opt_matchCase] Case-sensitive?\n * @return {!EqualTo} `<PropertyIsEqualTo>` operator.\n * @api\n */\nexport function equalTo(propertyName, expression, opt_matchCase) {\n  return new EqualTo(propertyName, expression, opt_matchCase);\n}\n\n/**\n * Creates a `<PropertyIsNotEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean} [opt_matchCase] Case-sensitive?\n * @return {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.\n * @api\n */\nexport function notEqualTo(propertyName, expression, opt_matchCase) {\n  return new NotEqualTo(propertyName, expression, opt_matchCase);\n}\n\n/**\n * Creates a `<PropertyIsLessThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @return {!LessThan} `<PropertyIsLessThan>` operator.\n * @api\n */\nexport function lessThan(propertyName, expression) {\n  return new LessThan(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @return {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.\n * @api\n */\nexport function lessThanOrEqualTo(propertyName, expression) {\n  return new LessThanOrEqualTo(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsGreaterThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @return {!GreaterThan} `<PropertyIsGreaterThan>` operator.\n * @api\n */\nexport function greaterThan(propertyName, expression) {\n  return new GreaterThan(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @return {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.\n * @api\n */\nexport function greaterThanOrEqualTo(propertyName, expression) {\n  return new GreaterThanOrEqualTo(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsNull>` comparison operator to test whether a property value\n * is null.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @return {!IsNull} `<PropertyIsNull>` operator.\n * @api\n */\nexport function isNull(propertyName) {\n  return new IsNull(propertyName);\n}\n\n/**\n * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression\n * value lies within a range given by a lower and upper bound (inclusive).\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} lowerBoundary The lower bound of the range.\n * @param {!number} upperBoundary The upper bound of the range.\n * @return {!IsBetween} `<PropertyIsBetween>` operator.\n * @api\n */\nexport function between(propertyName, lowerBoundary, upperBoundary) {\n  return new IsBetween(propertyName, lowerBoundary, upperBoundary);\n}\n\n/**\n * Represents a `<PropertyIsLike>` comparison operator that matches a string property\n * value against a text pattern.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} pattern Text pattern.\n * @param {string} [opt_wildCard] Pattern character which matches any sequence of\n *    zero or more string characters. Default is '*'.\n * @param {string} [opt_singleChar] pattern character which matches any single\n *    string character. Default is '.'.\n * @param {string} [opt_escapeChar] Escape character which can be used to escape\n *    the pattern characters. Default is '!'.\n * @param {boolean} [opt_matchCase] Case-sensitive?\n * @return {!IsLike} `<PropertyIsLike>` operator.\n * @api\n */\nexport function like(\n  propertyName,\n  pattern,\n  opt_wildCard,\n  opt_singleChar,\n  opt_escapeChar,\n  opt_matchCase\n) {\n  return new IsLike(\n    propertyName,\n    pattern,\n    opt_wildCard,\n    opt_singleChar,\n    opt_escapeChar,\n    opt_matchCase\n  );\n}\n\n/**\n * Create a `<During>` temporal operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} begin The begin date in ISO-8601 format.\n * @param {!string} end The end date in ISO-8601 format.\n * @return {!During} `<During>` operator.\n * @api\n */\nexport function during(propertyName, begin, end) {\n  return new During(propertyName, begin, end);\n}\n\nexport function resourceId(rid) {\n  return new ResourceId(rid);\n}\n","/**\n * @module ol/format/WFS\n */\nimport GML2 from './GML2.js';\nimport GML3 from './GML3.js';\nimport GML32 from './GML32.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport XMLFeature from './XMLFeature.js';\nimport {\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  isDocument,\n  makeArrayPusher,\n  makeChildAppender,\n  makeObjectPropertySetter,\n  makeSimpleNodeFactory,\n  parse,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {and as andFilterFn, bbox as bboxFilterFn} from './filter.js';\nimport {assert} from '../asserts.js';\nimport {assign} from '../obj.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  readNonNegativeIntegerString,\n  readPositiveInteger,\n  writeStringTextNode,\n} from './xsd.js';\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst FEATURE_COLLECTION_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'boundedBy': makeObjectPropertySetter(\n      GMLBase.prototype.readExtentElement,\n      'bounds'\n    ),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'member': makeArrayPusher(GMLBase.prototype.readFeaturesInternal),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_SUMMARY_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'totalInserted': makeObjectPropertySetter(readPositiveInteger),\n    'totalUpdated': makeObjectPropertySetter(readPositiveInteger),\n    'totalDeleted': makeObjectPropertySetter(readPositiveInteger),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'totalInserted': makeObjectPropertySetter(readPositiveInteger),\n    'totalUpdated': makeObjectPropertySetter(readPositiveInteger),\n    'totalDeleted': makeObjectPropertySetter(readPositiveInteger),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_RESPONSE_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'TransactionSummary': makeObjectPropertySetter(\n      readTransactionSummary,\n      'transactionSummary'\n    ),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds'),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'TransactionSummary': makeObjectPropertySetter(\n      readTransactionSummary,\n      'transactionSummary'\n    ),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds'),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst QUERY_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'PropertyName': makeChildAppender(writeStringTextNode),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'PropertyName': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst TRANSACTION_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative),\n  },\n};\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.\n * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.\n * @property {GMLBase} [gmlFormat] The GML format to use to parse the response.\n * Default is `ol/format/GML2` for WFS 1.0.0, `ol/format/GML3` for WFS 1.1.0 and `ol/format/GML32` for WFS 2.0.0.\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\n * @property {string} [version='1.1.0'] WFS version to use. Can be either `1.0.0`, `1.1.0` or `2.0.0`.\n */\n\n/**\n * @typedef {Object} WriteGetFeatureOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {Array<string|FeatureType>} featureTypes The feature type names or FeatureType objects to\n * define a unique bbox filter per feature type name (in this case, options `bbox` and `geometryName` are\n * ignored.).\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {string} [outputFormat] Output format.\n * @property {number} [maxFeatures] Maximum number of features to fetch.\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\n * @property {Array<string>} [propertyNames] Optional list of property names to serialize.\n * @property {string} [viewParams] viewParams GeoServer vendor parameter.\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\n * @property {number} [count] Number of features to retrieve when paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\n * Web Feature Services have repurposed `maxfeatures` instead.\n * @property {import(\"../extent.js\").Extent} [bbox] Extent to use for the BBOX filter. The `geometryName`\n * option must be set.\n * @property {import(\"./filter/Filter.js\").default} [filter] Filter condition. See\n * {@link module:ol/format/filter} for more information.\n * @property {string} [resultType] Indicates what response should be returned,\n * e.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\n */\n\n/**\n * @typedef {Object} FeatureType\n * @property {!string} name The feature type name.\n * @property {!import(\"../extent.js\").Extent} bbox Extent to use for the BBOX filter.\n * @property {!string} geometryName Geometry name to use in the BBOX filter.\n */\n\n/**\n * @typedef {Object} WriteTransactionOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {string} featureType The feature type name.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\n * @property {Array<Object>} nativeElements Native elements. Currently not supported.\n * @property {import(\"./GMLBase.js\").Options} [gmlOptions] GML options for the WFS transaction writer.\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0`, `1.1.0` or `2.0.0`.\n */\n\n/**\n * Number of features; bounds/extent.\n * @typedef {Object} FeatureCollectionMetadata\n * @property {number} numberOfFeatures NumberOfFeatures.\n * @property {import(\"../extent.js\").Extent} bounds Bounds.\n */\n\n/**\n * Total deleted; total inserted; total updated; array of insert ids.\n * @typedef {Object} TransactionResponse\n * @property {number} totalDeleted TotalDeleted.\n * @property {number} totalInserted TotalInserted.\n * @property {number} totalUpdated TotalUpdated.\n * @property {Array<string>} insertIds InsertIds.\n */\n\n/**\n * @type {string}\n */\nconst FEATURE_PREFIX = 'feature';\n\n/**\n * @type {string}\n */\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\n/**\n * @type {Object<string, string>}\n */\nconst OGCNS = {\n  '2.0.0': 'http://www.opengis.net/ogc/1.1',\n  '1.1.0': 'http://www.opengis.net/ogc',\n  '1.0.0': 'http://www.opengis.net/ogc',\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst WFSNS = {\n  '2.0.0': 'http://www.opengis.net/wfs/2.0',\n  '1.1.0': 'http://www.opengis.net/wfs',\n  '1.0.0': 'http://www.opengis.net/wfs',\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst FESNS = {\n  '2.0.0': 'http://www.opengis.net/fes/2.0',\n  '1.1.0': 'http://www.opengis.net/fes',\n  '1.0.0': 'http://www.opengis.net/fes',\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst SCHEMA_LOCATIONS = {\n  '2.0.0':\n    'http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd',\n  '1.1.0':\n    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n  '1.0.0':\n    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd',\n};\n\n/**\n * @type {Object<string, object>}\n */\nconst GML_FORMATS = {\n  '2.0.0': GML32,\n  '1.1.0': GML3,\n  '1.0.0': GML2,\n};\n\n/**\n * @const\n * @type {string}\n */\nconst DEFAULT_VERSION = '1.1.0';\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the WFS format.\n * By default, supports WFS version 1.1.0. You can pass a GML format\n * as option to override the default.\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\n *\n * @api\n */\nclass WFS extends XMLFeature {\n  /**\n   * @param {Options} [opt_options] Optional configuration object.\n   */\n  constructor(opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.version_ = options.version ? options.version : DEFAULT_VERSION;\n\n    /**\n     * @private\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType_ = options.featureType;\n\n    /**\n     * @private\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS_ = options.featureNS;\n\n    /**\n     * @private\n     * @type {GMLBase}\n     */\n    this.gmlFormat_ = options.gmlFormat\n      ? options.gmlFormat\n      : new GML_FORMATS[this.version_]();\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.schemaLocation_ = options.schemaLocation\n      ? options.schemaLocation\n      : SCHEMA_LOCATIONS[this.version_];\n  }\n\n  /**\n   * @return {Array<string>|string|undefined} featureType\n   */\n  getFeatureType() {\n    return this.featureType_;\n  }\n\n  /**\n   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.\n   */\n  setFeatureType(featureType) {\n    this.featureType_ = featureType;\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, opt_options) {\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node,\n    };\n    assign(context, {\n      'featureType': this.featureType_,\n      'featureNS': this.featureNS_,\n    });\n\n    assign(context, this.getReadOptions(node, opt_options ? opt_options : {}));\n    const objectStack = [context];\n    let featuresNS;\n    if (this.version_ === '2.0.0') {\n      featuresNS = FEATURE_COLLECTION_PARSERS;\n    } else {\n      featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;\n    }\n    let features = pushParseAndPop(\n      [],\n      featuresNS,\n      node,\n      objectStack,\n      this.gmlFormat_\n    );\n    if (!features) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * Read transaction response of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {TransactionResponse|undefined} Transaction response.\n   * @api\n   */\n  readTransactionResponse(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readTransactionResponseFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readTransactionResponseFromDocument(\n        /** @type {Document} */ (source)\n      );\n    } else {\n      return this.readTransactionResponseFromNode(\n        /** @type {Element} */ (source)\n      );\n    }\n  }\n\n  /**\n   * Read feature collection metadata of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   * @api\n   */\n  readFeatureCollectionMetadata(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureCollectionMetadataFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readFeatureCollectionMetadataFromDocument(\n        /** @type {Document} */ (source)\n      );\n    } else {\n      return this.readFeatureCollectionMetadataFromNode(\n        /** @type {Element} */ (source)\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFeatureCollectionMetadataFromNode(\n          /** @type {Element} */ (n)\n        );\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromNode(node) {\n    const result = {};\n    const value = readNonNegativeIntegerString(\n      node.getAttribute('numberOfFeatures')\n    );\n    result['numberOfFeatures'] = value;\n    return pushParseAndPop(\n      /** @type {FeatureCollectionMetadata} */ (result),\n      FEATURE_COLLECTION_PARSERS,\n      node,\n      [],\n      this.gmlFormat_\n    );\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readTransactionResponseFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromNode(node) {\n    return pushParseAndPop(\n      /** @type {TransactionResponse} */ ({}),\n      TRANSACTION_RESPONSE_PARSERS,\n      node,\n      []\n    );\n  }\n\n  /**\n   * Encode format as WFS `GetFeature` and return the Node.\n   *\n   * @param {WriteGetFeatureOptions} options Options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeGetFeature(options) {\n    const node = createElementNS(WFSNS[this.version_], 'GetFeature');\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', this.version_);\n    if (options.handle) {\n      node.setAttribute('handle', options.handle);\n    }\n    if (options.outputFormat) {\n      node.setAttribute('outputFormat', options.outputFormat);\n    }\n    if (options.maxFeatures !== undefined) {\n      node.setAttribute('maxFeatures', String(options.maxFeatures));\n    }\n    if (options.resultType) {\n      node.setAttribute('resultType', options.resultType);\n    }\n    if (options.startIndex !== undefined) {\n      node.setAttribute('startIndex', String(options.startIndex));\n    }\n    if (options.count !== undefined) {\n      node.setAttribute('count', String(options.count));\n    }\n    if (options.viewParams !== undefined) {\n      node.setAttribute('viewParams', options.viewParams);\n    }\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      this.schemaLocation_\n    );\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node,\n    };\n    assign(context, {\n      'version': this.version_,\n      'srsName': options.srsName,\n      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n      'featurePrefix': options.featurePrefix,\n      'propertyNames': options.propertyNames ? options.propertyNames : [],\n    });\n    assert(Array.isArray(options.featureTypes), 11); // `options.featureTypes` must be an Array\n    if (typeof options.featureTypes[0] === 'string') {\n      let filter = options.filter;\n      if (options.bbox) {\n        assert(options.geometryName, 12); // `options.geometryName` must also be provided when `options.bbox` is set\n        filter = this.combineBboxAndFilter(\n          options.geometryName,\n          options.bbox,\n          options.srsName,\n          filter\n        );\n      }\n      assign(context, {\n        'geometryName': options.geometryName,\n        'filter': filter,\n      });\n      writeGetFeature(\n        node,\n        /** @type {!Array<string>} */ (options.featureTypes),\n        [context]\n      );\n    } else {\n      // Write one query node per element in featuresType.\n      options.featureTypes.forEach((/** @type {FeatureType} */ featureType) => {\n        const completeFilter = this.combineBboxAndFilter(\n          featureType.geometryName,\n          featureType.bbox,\n          options.srsName,\n          options.filter\n        );\n        assign(context, {\n          'geometryName': featureType.geometryName,\n          'filter': completeFilter,\n        });\n        writeGetFeature(node, [featureType.name], [context]);\n      });\n    }\n    return node;\n  }\n\n  /**\n   * Create a bbox filter and combine it with another optional filter.\n   *\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!import(\"../extent.js\").Extent} extent Extent.\n   * @param {string} [opt_srsName] SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @param {import(\"./filter/Filter.js\").default} [opt_filter] Filter condition.\n   * @return {import(\"./filter/Filter.js\").default} The filter.\n   */\n  combineBboxAndFilter(geometryName, extent, opt_srsName, opt_filter) {\n    const bboxFilter = bboxFilterFn(geometryName, extent, opt_srsName);\n    if (opt_filter) {\n      // if bbox and filter are both set, combine the two into a single filter\n      return andFilterFn(opt_filter, bboxFilter);\n    }\n    return bboxFilter;\n  }\n\n  /**\n   * Encode format as WFS `Transaction` and return the Node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} inserts The features to insert.\n   * @param {Array<import(\"../Feature.js\").default>} updates The features to update.\n   * @param {Array<import(\"../Feature.js\").default>} deletes The features to delete.\n   * @param {WriteTransactionOptions} options Write options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeTransaction(inserts, updates, deletes, options) {\n    const objectStack = [];\n    const version = options.version ? options.version : this.version_;\n    const node = createElementNS(WFSNS[version], 'Transaction');\n\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', version);\n    let baseObj;\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    if (options) {\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n    }\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      SCHEMA_LOCATIONS[version]\n    );\n\n    const request = createTransactionRequest(node, baseObj, version, options);\n    if (inserts) {\n      serializeTransactionRequest('Insert', inserts, objectStack, request);\n    }\n    if (updates) {\n      serializeTransactionRequest('Update', updates, objectStack, request);\n    }\n    if (deletes) {\n      serializeTransactionRequest('Delete', deletes, objectStack, request);\n    }\n    if (options.nativeElements) {\n      serializeTransactionRequest(\n        'Native',\n        options.nativeElements,\n        objectStack,\n        request\n      );\n    }\n    return node;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readProjectionFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    if (node.firstElementChild && node.firstElementChild.firstElementChild) {\n      node = node.firstElementChild.firstElementChild;\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        if (\n          !(\n            n.childNodes.length === 0 ||\n            (n.childNodes.length === 1 && n.firstChild.nodeType === 3)\n          )\n        ) {\n          const objectStack = [{}];\n          this.gmlFormat_.readGeometryElement(n, objectStack);\n          return getProjection(objectStack.pop().srsName);\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {*} baseObj Base object.\n * @param {string} version Version.\n * @param {WriteTransactionOptions} options Options.\n * @return {Object} Request object.\n */\nfunction createTransactionRequest(node, baseObj, version, options) {\n  const featurePrefix = options.featurePrefix\n    ? options.featurePrefix\n    : FEATURE_PREFIX;\n  let gmlVersion;\n  if (version === '1.0.0') {\n    gmlVersion = 2;\n  } else if (version === '1.1.0') {\n    gmlVersion = 3;\n  } else if (version === '2.0.0') {\n    gmlVersion = 3.2;\n  }\n  const obj = assign(\n    {node},\n    {\n      version,\n      'featureNS': options.featureNS,\n      'featureType': options.featureType,\n      'featurePrefix': featurePrefix,\n      'gmlVersion': gmlVersion,\n      'hasZ': options.hasZ,\n      'srsName': options.srsName,\n    },\n    baseObj\n  );\n  return obj;\n}\n\n/**\n * @param {string} type Request type.\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {Array<*>} objectStack Object stack.\n * @param {Element} request Transaction Request.\n */\nfunction serializeTransactionRequest(type, features, objectStack, request) {\n  pushSerializeAndPop(\n    request,\n    TRANSACTION_SERIALIZERS,\n    makeSimpleNodeFactory(type),\n    features,\n    objectStack\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Transaction Summary.\n */\nfunction readTransactionSummary(node, objectStack) {\n  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst OGC_FID_PARSERS = {\n  'http://www.opengis.net/ogc': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    }),\n  },\n  'http://www.opengis.net/ogc/1.1': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    }),\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction fidParser(node, objectStack) {\n  parseNode(OGC_FID_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst INSERT_RESULTS_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'Feature': fidParser,\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Feature': fidParser,\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<string>|undefined} Insert results.\n */\nfunction readInsertResults(node, objectStack) {\n  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFeature(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const featureType = context['featureType'];\n  const featureNS = context['featureNS'];\n  const gmlVersion = context['gmlVersion'];\n  const child = createElementNS(featureNS, featureType);\n  node.appendChild(child);\n  if (gmlVersion === 2) {\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\n  } else if (gmlVersion === 3) {\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\n  } else {\n    GML32.prototype.writeFeatureElement(child, feature, objectStack);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {number|string} fid Feature identifier.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeOgcFidFilter(node, fid, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const version = context['version'];\n  const ns = OGCNS[version];\n  const filter = createElementNS(ns, 'Filter');\n  const child = createElementNS(ns, 'FeatureId');\n  filter.appendChild(child);\n  child.setAttribute('fid', /** @type {string} */ (fid));\n  node.appendChild(filter);\n}\n\n/**\n * @param {string|undefined} featurePrefix The prefix of the feature.\n * @param {string} featureType The type of the feature.\n * @return {string} The value of the typeName property.\n */\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  const prefix = featurePrefix + ':';\n  // The featureType already contains the prefix.\n  if (featureType.indexOf(prefix) === 0) {\n    return featureType;\n  } else {\n    return prefix + featureType;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDelete(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 26); // Features must have an id set\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeUpdate(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 27); // Features must have an id set\n  const version = context['version'];\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  const geometryName = feature.getGeometryName();\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    const keys = feature.getKeys();\n    const values = [];\n    for (let i = 0, ii = keys.length; i < ii; i++) {\n      const value = feature.get(keys[i]);\n      if (value !== undefined) {\n        let name = keys[i];\n        if (\n          value &&\n          typeof (/** @type {?} */ (value).getSimplifiedGeometry) === 'function'\n        ) {\n          name = geometryName;\n        }\n        values.push({name: name, value: value});\n      }\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */ ({\n        version,\n        'gmlVersion': context['gmlVersion'],\n        node,\n        'hasZ': context['hasZ'],\n        'srsName': context['srsName'],\n      }),\n      TRANSACTION_SERIALIZERS,\n      makeSimpleNodeFactory('Property'),\n      values,\n      objectStack\n    );\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {Object} pair Property name and value.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeProperty(node, pair, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const version = context['version'];\n  const ns = WFSNS[version];\n  const name = createElementNS(ns, 'Name');\n  const gmlVersion = context['gmlVersion'];\n  node.appendChild(name);\n  writeStringTextNode(name, pair.name);\n  if (pair.value !== undefined && pair.value !== null) {\n    const value = createElementNS(ns, 'Value');\n    node.appendChild(value);\n    if (\n      pair.value &&\n      typeof (/** @type {?} */ (pair.value).getSimplifiedGeometry) ===\n        'function'\n    ) {\n      if (gmlVersion === 2) {\n        GML2.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else if (gmlVersion === 3) {\n        GML3.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else {\n        GML32.prototype.writeGeometryElement(value, pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNative(node, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node.setAttribute('vendorId', nativeElement.vendorId);\n  }\n  if (nativeElement.safeToIgnore !== undefined) {\n    node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));\n  }\n  if (nativeElement.value !== undefined) {\n    writeStringTextNode(node, nativeElement.value);\n  }\n}\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst GETFEATURE_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Query': makeChildAppender(writeQuery),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Query': makeChildAppender(writeQuery),\n  },\n  'http://www.opengis.net/ogc': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeSpatialFilter),\n    'Intersects': makeChildAppender(writeSpatialFilter),\n    'Within': makeChildAppender(writeSpatialFilter),\n    'DWithin': makeChildAppender(writeDWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter),\n  },\n  'http://www.opengis.net/fes/2.0': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeSpatialFilter),\n    'Disjoint': makeChildAppender(writeSpatialFilter),\n    'Intersects': makeChildAppender(writeSpatialFilter),\n    'ResourceId': makeChildAppender(writeResourceIdFilter),\n    'Within': makeChildAppender(writeSpatialFilter),\n    'DWithin': makeChildAppender(writeDWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter),\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {string} featureType Feature type.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeQuery(node, featureType, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const version = context['version'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const propertyNames = context['propertyNames'];\n  const srsName = context['srsName'];\n  let typeName;\n  // If feature prefix is not defined, we must not use the default prefix.\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n  let typeNameAttr;\n  if (version === '2.0.0') {\n    typeNameAttr = 'typeNames';\n  } else {\n    typeNameAttr = 'typeName';\n  }\n  node.setAttribute(typeNameAttr, typeName);\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  if (featureNS) {\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  }\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n    assign({}, context)\n  );\n  item.node = node;\n  pushSerializeAndPop(\n    item,\n    QUERY_SERIALIZERS,\n    makeSimpleNodeFactory('PropertyName'),\n    propertyNames,\n    objectStack\n  );\n  const filter = context['filter'];\n  if (filter) {\n    const child = createElementNS(getFilterNS(version), 'Filter');\n    node.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFilterCondition(node, filter, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node};\n  assign(item, {context});\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(filter.getTagName()),\n    [filter],\n    objectStack\n  );\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Bbox.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeBboxFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  parent['srsName'] = filter.srsName;\n  const format = GML_FORMATS[version];\n\n  writePropertyName(version, node, filter.geometryName);\n  format.prototype.writeGeometryElement(node, filter.extent, objectStack);\n}\n\n/**\n * @param {Element} node Element.\n * @param {import(\"./filter/ResourceId.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeResourceIdFilter(node, filter, objectStack) {\n  node.setAttribute('rid', /** @type {string} */ (filter.rid));\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Spatial.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeSpatialFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  parent['srsName'] = filter.srsName;\n  const format = GML_FORMATS[version];\n\n  writePropertyName(version, node, filter.geometryName);\n  format.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/DWithin.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDWithinFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  writeSpatialFilter(node, filter, objectStack);\n  const distance = createElementNS(getFilterNS(version), 'Distance');\n  writeStringTextNode(distance, filter.distance.toString());\n  if (version === '2.0.0') {\n    distance.setAttribute('uom', filter.unit);\n  } else {\n    distance.setAttribute('units', filter.unit);\n  }\n  node.appendChild(distance);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/During.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDuringFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n\n  writeExpression(FESNS[version], 'ValueReference', node, filter.propertyName);\n  const timePeriod = createElementNS(GMLNS, 'TimePeriod');\n\n  node.appendChild(timePeriod);\n\n  const begin = createElementNS(GMLNS, 'begin');\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n\n  const end = createElementNS(GMLNS, 'end');\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/LogicalNary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeLogicalFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node};\n  assign(item, {context});\n  const conditions = filter.conditions;\n  for (let i = 0, ii = conditions.length; i < ii; ++i) {\n    const condition = conditions[i];\n    pushSerializeAndPop(\n      item,\n      GETFEATURE_SERIALIZERS,\n      makeSimpleNodeFactory(condition.getTagName()),\n      [condition],\n      objectStack\n    );\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/Not.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNotFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node};\n  assign(item, {context});\n  const condition = filter.condition;\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(condition.getTagName()),\n    [condition],\n    objectStack\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/ComparisonBinary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeComparisonFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writePropertyName(version, node, filter.propertyName);\n  writeLiteral(version, node, '' + filter.expression);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsNull.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsNullFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  writePropertyName(version, node, filter.propertyName);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsBetween.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsBetweenFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  const ns = getFilterNS(version);\n\n  writePropertyName(version, node, filter.propertyName);\n\n  const lowerBoundary = createElementNS(ns, 'LowerBoundary');\n  node.appendChild(lowerBoundary);\n  writeLiteral(version, lowerBoundary, '' + filter.lowerBoundary);\n\n  const upperBoundary = createElementNS(ns, 'UpperBoundary');\n  node.appendChild(upperBoundary);\n  writeLiteral(version, upperBoundary, '' + filter.upperBoundary);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/IsLike.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsLikeFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  node.setAttribute('wildCard', filter.wildCard);\n  node.setAttribute('singleChar', filter.singleChar);\n  node.setAttribute('escapeChar', filter.escapeChar);\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writePropertyName(version, node, filter.propertyName);\n  writeLiteral(version, node, '' + filter.pattern);\n}\n\n/**\n * @param {string} ns Namespace.\n * @param {string} tagName Tag name.\n * @param {Node} node Node.\n * @param {string} value Value.\n */\nfunction writeExpression(ns, tagName, node, value) {\n  const property = createElementNS(ns, tagName);\n  writeStringTextNode(property, value);\n  node.appendChild(property);\n}\n\n/**\n * @param {string} version Version.\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeLiteral(version, node, value) {\n  writeExpression(getFilterNS(version), 'Literal', node, value);\n}\n\n/**\n * @param {string} version Version.\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writePropertyName(version, node, value) {\n  if (version === '2.0.0') {\n    writeExpression(FESNS[version], 'ValueReference', node, value);\n  } else {\n    writeExpression(OGCNS[version], 'PropertyName', node, value);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {string} time PropertyName value.\n */\nfunction writeTimeInstant(node, time) {\n  const timeInstant = createElementNS(GMLNS, 'TimeInstant');\n  node.appendChild(timeInstant);\n\n  const timePosition = createElementNS(GMLNS, 'timePosition');\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time);\n}\n\n/**\n * Encode filter as WFS `Filter` and return the Node.\n *\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {string} opt_version WFS version. If not provided defaults to '1.1.0'\n * @return {Node} Result.\n * @api\n */\nexport function writeFilter(filter, opt_version) {\n  const version = opt_version || '1.1.0';\n  const child = createElementNS(getFilterNS(version), 'Filter');\n  const context = {\n    node: child,\n  };\n  assign(context, {\n    'version': version,\n    'filter': filter,\n  });\n  writeFilterCondition(child, filter, [context]);\n  return child;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<string>} featureTypes Feature types.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeGetFeature(node, featureTypes, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n    assign({}, context)\n  );\n  item.node = node;\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory('Query'),\n    featureTypes,\n    objectStack\n  );\n}\n\nfunction getFilterNS(version) {\n  let ns;\n  if (version === '2.0.0') {\n    ns = FESNS[version];\n  } else {\n    ns = OGCNS[version];\n  }\n  return ns;\n}\n\nexport default WFS;\n","import Map from '../src/ol/Map.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport View from '../src/ol/View.js';\nimport XYZ from '../src/ol/source/XYZ.js';\nimport {GeoJSON, WFS} from '../src/ol/format.js';\nimport {Stroke, Style} from '../src/ol/style.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\nimport {\n  and as andFilter,\n  equalTo as equalToFilter,\n  like as likeFilter,\n} from '../src/ol/format/filter.js';\n\nconst vectorSource = new VectorSource();\nconst vector = new VectorLayer({\n  source: vectorSource,\n  style: new Style({\n    stroke: new Stroke({\n      color: 'rgba(0, 0, 255, 1.0)',\n      width: 2,\n    }),\n  }),\n});\n\nconst key = 'get_your_own_D6rA4zTHduk6KOKTXzGB';\nconst attributions =\n  '<a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\">&copy; MapTiler</a> ' +\n  '<a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">&copy; OpenStreetMap contributors</a>';\n\nconst raster = new TileLayer({\n  source: new XYZ({\n    attributions: attributions,\n    url: 'https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=' + key,\n    maxZoom: 20,\n  }),\n});\n\nconst map = new Map({\n  layers: [raster, vector],\n  target: document.getElementById('map'),\n  view: new View({\n    center: [-8908887.277395891, 5381918.072437216],\n    maxZoom: 19,\n    zoom: 12,\n  }),\n});\n\n// generate a GetFeature request\nconst featureRequest = new WFS().writeGetFeature({\n  srsName: 'EPSG:3857',\n  featureNS: 'http://openstreemap.org',\n  featurePrefix: 'osm',\n  featureTypes: ['water_areas'],\n  outputFormat: 'application/json',\n  filter: andFilter(\n    likeFilter('name', 'Mississippi*'),\n    equalToFilter('waterway', 'riverbank')\n  ),\n});\n\n// then post the request and add the received features to a layer\nfetch('https://ahocevar.com/geoserver/wfs', {\n  method: 'POST',\n  body: new XMLSerializer().serializeToString(featureRequest),\n})\n  .then(function (response) {\n    return response.json();\n  })\n  .then(function (json) {\n    const features = new GeoJSON().readFeatures(json);\n    vectorSource.addFeatures(features);\n    map.getView().fit(vectorSource.getExtent());\n  });\n"],"names":["schemaLocation","GMLNS","MULTIGEOMETRY_TO_MEMBER_NODENAME","GML3","opt_options","options","surface_","undefined","surface","curve_","curve","multiCurve_","multiCurve","multiSurface_","multiSurface","hasZ","node","objectStack","lineStrings","pushParseAndPop","this","MULTICURVE_PARSERS","MultiLineString","flatCoordinates","i","ii","length","extend","getFlatCoordinates","polygons","MULTISURFACE_PARSERS","MultiPolygon","parseNode","CURVEMEMBER_PARSERS","SURFACEMEMBER_PARSERS","PATCHES_PARSERS","SEGMENTS_PARSERS","FLAT_LINEAR_RINGS_PARSERS","GEOMETRY_FLAT_COORDINATES_PARSERS","flatLinearRing","RING_PARSERS","push","flatLinearRings","SURFACE_PARSERS","ends","Polygon","GeometryLayout","CURVE_PARSERS","LineString","ENVELOPE_PARSERS","createOrUpdate","m","s","getAllTextContent","re","exec","parseFloat","substr","containerSrs","axisOrientation","getProjection","getAxisOrientation","y","x","len","replace","context","contextDimension","z","coords","split","dim","getAttribute","readNonNegativeIntegerString","parentNode","value","srsDimension","setAttribute","srsName","point","getCoordinates","writeStringTextNode","opt_srsName","opt_hasZ","points","parts","Array","getCoords_","join","geometry","pos","createElementNS","namespaceURI","appendChild","writePos_","extent","values","pushSerializeAndPop","ENVELOPE_SERIALIZERS","OBJECT_PROPERTY_NODE_FACTORY","posList","writePosList_","opt_nodeName","exteriorWritten","nodeName","rings","getLinearRings","RING_SERIALIZERS","RING_NODE_FACTORY_","patches","writeSurfacePatches_","segments","writeCurveSegments_","getPolygons","SURFACEORPOLYGONMEMBER_SERIALIZERS","MULTIGEOMETRY_MEMBER_NODE_FACTORY_","getPoints","POINTMEMBER_SERIALIZERS","makeSimpleNodeFactory","lines","getLineStrings","LINESTRINGORCURVEMEMBER_SERIALIZERS","ring","linearRing","writeLinearRing","polygon","child","GEOMETRY_NODE_FACTORY_","writeSurfaceOrPolygon","writePoint","line","writeCurveOrLineString","item","assign","isArray","transformExtentWithOptions","transformGeometryWithOptions","GEOMETRY_SERIALIZERS","feature","fid","getId","featureNS","geometryName","getGeometryName","serializers","keys","hasProperties","properties","getProperties","key","getSimplifiedGeometry","makeChildAppender","writeGeometryElement","features","featureType","writeFeatureElement","namespace","getType","adaptOptions","geom","setAttributeNS","XML_SCHEMA_INSTANCE_URI","writeFeatureMembers_","GMLBase","prototype","makeReplacer","readFlatPos","readFlatPosList","GML2","interiorParser","exteriorParser","GEOMETRY_PARSERS","readSurface","readMultiSurface","readCurve","readMultiCurve","readEnvelope","makeArrayPusher","curveMemberParser","surfaceMemberParser","readPatch","readSegment","readPolygonPatch","makeArrayExtender","readLineStringSegment","readFlatCurveRing","writeFeatures","writeRing","writeSurfaceOrPolygonMember","writePointMember","writeLineStringOrCurveMember","writeMultiCurveOrLineString","writeMultiPoint","writeMultiSurfaceOrPolygon","writeEnvelope","GML32","MULTIPOINT_PARSERS","MULTILINESTRING_PARSERS","MULTIPOLYGON_PARSERS","POINTMEMBER_PARSERS","LINESTRINGMEMBER_PARSERS","POLYGONMEMBER_PARSERS","Filter","tagName","tagName_","And","conditions","slice","call","arguments","LogicalNary","assert","Bbox","Error","Comparison","propertyName","EqualTo","expression","opt_matchCase","ComparisonBinary","matchCase","IsLike","pattern","opt_wildCard","opt_singleChar","opt_escapeChar","wildCard","singleChar","escapeChar","and","params","concat","Function","bind","apply","FEATURE_COLLECTION_PARSERS","makeObjectPropertySetter","TRANSACTION_SUMMARY_PARSERS","readPositiveInteger","TRANSACTION_RESPONSE_PARSERS","readTransactionSummary","readInsertResults","QUERY_SERIALIZERS","TRANSACTION_SERIALIZERS","writeFeature","writeUpdate","writeDelete","writeProperty","writeNative","FEATURE_PREFIX","XMLNS","OGCNS","WFSNS","FESNS","SCHEMA_LOCATIONS","GML_FORMATS","WFS","version_","version","featureType_","featureNS_","gmlFormat_","gmlFormat","schemaLocation_","getReadOptions","featuresNS","source","doc","parse","readTransactionResponseFromDocument","isDocument","readTransactionResponseFromNode","readFeatureCollectionMetadataFromDocument","readFeatureCollectionMetadataFromNode","n","firstChild","nextSibling","nodeType","Node","ELEMENT_NODE","result","handle","outputFormat","maxFeatures","String","resultType","startIndex","count","viewParams","featurePrefix","propertyNames","featureTypes","filter","bbox","combineBboxAndFilter","writeGetFeature","forEach","completeFilter","name","opt_filter","bboxFilter","bboxFilterFn","andFilterFn","inserts","updates","deletes","baseObj","gmlOptions","request","gmlVersion","createTransactionRequest","serializeTransactionRequest","nativeElements","readProjectionFromNode","firstElementChild","nextElementSibling","childNodes","readGeometryElement","pop","XMLFeature","type","OGC_FID_PARSERS","fidParser","INSERT_RESULTS_PARSERS","writeOgcFidFilter","ns","getTypeName","prefix","indexOf","typeName","getKeys","get","pair","nativeElement","vendorId","safeToIgnore","GETFEATURE_SERIALIZERS","writeQuery","writeDuringFilter","writeLogicalFilter","writeNotFilter","writeBboxFilter","writeSpatialFilter","writeDWithinFilter","writeComparisonFilter","writeIsNullFilter","writeIsBetweenFilter","writeIsLikeFilter","rid","typeNameAttr","getFilterNS","writeFilterCondition","getTagName","parent","format","writePropertyName","distance","toString","unit","writeExpression","timePeriod","begin","writeTimeInstant","end","condition","writeLiteral","lowerBoundary","upperBoundary","property","time","timeInstant","timePosition","vectorSource","VectorSource","vector","VectorLayer","style","Style","stroke","Stroke","color","width","raster","TileLayer","XYZ","attributions","url","maxZoom","map","Map","layers","target","document","getElementById","view","View","center","zoom","featureRequest","andFilter","equalToFilter","fetch","method","body","XMLSerializer","serializeToString","then","response","json","GeoJSON","readFeatures","addFeatures","getView","fit","getExtent"],"sourceRoot":""}