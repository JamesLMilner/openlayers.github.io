{"version":3,"file":"wkb.js","mappings":"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","sources":["webpack:///../src/ol/format/WKB.js","webpack:///./wkb.js"],"sourcesContent":["/**\n * @module ol/format/WKB\n */\nimport Feature from '../Feature.js';\nimport FeatureFormat, {transformGeometryWithOptions} from './Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\n\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\nimport {assign} from '../obj.js';\n\n// WKB spec: https://www.ogc.org/standards/sfa\n// EWKB spec: https://raw.githubusercontent.com/postgis/postgis/2.1.0/doc/ZMSgeoms.txt\n\n/**\n * @const\n * @enum {number}\n */\nconst WKBGeometryType = {\n  POINT: 1,\n  LINE_STRING: 2,\n  POLYGON: 3,\n  MULTI_POINT: 4,\n  MULTI_LINE_STRING: 5,\n  MULTI_POLYGON: 6,\n  GEOMETRY_COLLECTION: 7,\n\n  /*\n  CIRCULAR_STRING: 8,\n  COMPOUND_CURVE: 9,\n  CURVE_POLYGON: 10,\n\n  MULTI_CURVE: 11,\n  MULTI_SURFACE: 12,\n  CURVE: 13,\n  SURFACE: 14,\n  */\n\n  POLYHEDRAL_SURFACE: 15,\n  TIN: 16,\n  TRIANGLE: 17,\n};\n\nclass WkbReader {\n  /**\n   * @param {DataView} view source to read\n   */\n  constructor(view) {\n    /** @private */\n    this.view_ = view;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pos_ = 0;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.initialized_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.isLittleEndian_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasZ_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasM_ = false;\n\n    /**\n     * @type {number|null}\n     * @private\n     */\n    this.srid_ = null;\n\n    /**\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     * @private\n     */\n    this.layout_ = 'XY';\n  }\n\n  /**\n   * @return {number} value\n   */\n  readUint8() {\n    return this.view_.getUint8(this.pos_++);\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readUint32(isLittleEndian) {\n    return this.view_.getUint32(\n      (this.pos_ += 4) - 4,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_\n    );\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readDouble(isLittleEndian) {\n    return this.view_.getFloat64(\n      (this.pos_ += 8) - 8,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_\n    );\n  }\n\n  /**\n   * @return {import('../coordinate.js').Coordinate} coords for Point\n   */\n  readPoint() {\n    /** @type import('../coordinate.js').Coordinate */\n    const coords = [];\n\n    coords.push(this.readDouble());\n    coords.push(this.readDouble());\n    if (this.hasZ_) {\n      coords.push(this.readDouble());\n    }\n    if (this.hasM_) {\n      coords.push(this.readDouble());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing\n   */\n  readLineString() {\n    const numPoints = this.readUint32();\n\n    /** @type Array<import('../coordinate.js').Coordinate> */\n    const coords = [];\n    for (let i = 0; i < numPoints; i++) {\n      coords.push(this.readPoint());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like\n   */\n  readPolygon() {\n    const numRings = this.readUint32();\n\n    /** @type Array<Array<import('../coordinate.js').Coordinate>> */\n    const rings = [];\n    for (let i = 0; i < numRings; i++) {\n      rings.push(this.readLineString()); // as a LinearRing\n    }\n\n    return rings;\n  }\n\n  /**\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {number} WKB Type ID\n   */\n  readWkbHeader(expectedTypeId) {\n    const byteOrder = this.readUint8();\n    const isLittleEndian = byteOrder > 0;\n\n    const wkbType = this.readUint32(isLittleEndian);\n    const wkbTypeThousandth = Math.floor((wkbType & 0x0fffffff) / 1000);\n    const hasZ =\n      Boolean(wkbType & 0x80000000) ||\n      wkbTypeThousandth === 1 ||\n      wkbTypeThousandth === 3;\n    const hasM =\n      Boolean(wkbType & 0x40000000) ||\n      wkbTypeThousandth === 2 ||\n      wkbTypeThousandth === 3;\n    const hasSRID = Boolean(wkbType & 0x20000000);\n    const typeId = (wkbType & 0x0fffffff) % 1000; // Assume 1000 is an upper limit for type ID\n    const layout = /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */ (\n      ['XY', hasZ ? 'Z' : '', hasM ? 'M' : ''].join('')\n    );\n\n    const srid = hasSRID ? this.readUint32(isLittleEndian) : null;\n\n    if (expectedTypeId !== undefined && expectedTypeId !== typeId) {\n      throw new Error('Unexpected WKB geometry type ' + typeId);\n    }\n\n    if (this.initialized_) {\n      // sanity checks\n      if (this.isLittleEndian_ !== isLittleEndian) {\n        throw new Error('Inconsistent endian');\n      }\n      if (this.layout_ !== layout) {\n        throw new Error('Inconsistent geometry layout');\n      }\n      if (srid && this.srid_ !== srid) {\n        throw new Error('Inconsistent coordinate system (SRID)');\n      }\n    } else {\n      this.isLittleEndian_ = isLittleEndian;\n      this.hasZ_ = hasZ;\n      this.hasM_ = hasM;\n      this.layout_ = layout;\n      this.srid_ = srid;\n      this.initialized_ = true;\n    }\n\n    return typeId;\n  }\n\n  /**\n   * @param {number} typeId WKB Type ID\n   * @return {any} values read\n   */\n  readWkbPayload(typeId) {\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return this.readPoint();\n\n      case WKBGeometryType.LINE_STRING:\n        return this.readLineString();\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return this.readPolygon();\n\n      case WKBGeometryType.MULTI_POINT:\n        return this.readMultiPoint();\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return this.readMultiLineString();\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return this.readMultiPolygon();\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return this.readGeometryCollection();\n\n      default:\n        throw new Error(\n          'Unsupported WKB geometry type ' + typeId + ' is found'\n        );\n    }\n  }\n\n  /**\n   * @param {number} expectedTypeId Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbBlock(expectedTypeId) {\n    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));\n  }\n\n  /**\n   * @param {Function} reader reader function for each item\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbCollection(reader, expectedTypeId) {\n    const num = this.readUint32();\n\n    const items = [];\n    for (let i = 0; i < num; i++) {\n      const result = reader.call(this, expectedTypeId);\n      if (result) {\n        items.push(result);\n      }\n    }\n\n    return items;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint\n   */\n  readMultiPoint() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like\n   */\n  readMultiLineString() {\n    return this.readWkbCollection(\n      this.readWkbBlock,\n      WKBGeometryType.LINE_STRING\n    );\n  }\n\n  /**\n   * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like\n   */\n  readMultiPolygon() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);\n  }\n\n  /**\n   * @return {Array<import('../geom/Geometry.js').default>} array of geometries\n   */\n  readGeometryCollection() {\n    return this.readWkbCollection(this.readGeometry);\n  }\n\n  /**\n   * @return {import('../geom/Geometry.js').default} geometry\n   */\n  readGeometry() {\n    const typeId = this.readWkbHeader();\n    const result = this.readWkbPayload(typeId);\n\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return new Point(\n          /** @type {import('../coordinate.js').Coordinate} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.LINE_STRING:\n        return new LineString(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return new Polygon(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_POINT:\n        return new MultiPoint(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return new MultiLineString(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return new MultiPolygon(\n          /** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return new GeometryCollection(\n          /** @type {Array<import('../geom/Geometry.js').default>} */ (result)\n        );\n\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * @return {number|null} SRID in the EWKB. `null` if not defined.\n   */\n  getSrid() {\n    return this.srid_;\n  }\n}\n\nclass WkbWriter {\n  /**\n   * @type {Object}\n   * @property {string} [layout] geometryLayout\n   * @property {boolean} [littleEndian=true] littleEndian\n   * @property {boolean} [ewkb=true] Whether writes in EWKB format\n   * @property {Object} [nodata] NoData value for each axes\n   * @param {Object} opts options\n   */\n  constructor(opts) {\n    opts = opts || {};\n\n    /** @type {string} */\n    this.layout_ = opts.layout;\n    this.isLittleEndian_ = opts.littleEndian !== false;\n\n    this.isEWKB_ = opts.ewkb !== false;\n\n    /** @type {Array<Array<number>>} */\n    this.writeQueue_ = [];\n\n    /**\n     * @type {Object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} Z NoData value for Z\n     * @property {number} M NoData value for M\n     */\n    this.nodata_ = assign({X: 0, Y: 0, Z: 0, M: 0}, opts.nodata);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint8(value) {\n    this.writeQueue_.push([1, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint32(value) {\n    this.writeQueue_.push([4, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeDouble(value) {\n    this.writeQueue_.push([8, value]);\n  }\n\n  /**\n   * @param {import('../coordinate.js').Coordinate} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writePoint(coords, layout) {\n    /**\n     * @type {Object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} [Z] NoData value for Z\n     * @property {number} [M] NoData value for M\n     */\n    const coordsObj = assign.apply(\n      null,\n      layout.split('').map((axis, idx) => ({[axis]: coords[idx]}))\n    );\n\n    for (const axis of this.layout_) {\n      this.writeDouble(\n        axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]\n      );\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeLineString(coords, layout) {\n    this.writeUint32(coords.length); // numPoints\n    for (let i = 0; i < coords.length; i++) {\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writePolygon(rings, layout) {\n    this.writeUint32(rings.length); // numRings\n    for (let i = 0; i < rings.length; i++) {\n      this.writeLineString(rings[i], layout); // as a LinearRing\n    }\n  }\n\n  /**\n   * @param {number} wkbType WKB Type ID\n   * @param {number} [srid] SRID\n   */\n  writeWkbHeader(wkbType, srid) {\n    wkbType %= 1000; // Assume 1000 is an upper limit for type ID\n    if (this.layout_.indexOf('Z') >= 0) {\n      wkbType += this.isEWKB_ ? 0x80000000 : 1000;\n    }\n    if (this.layout_.indexOf('M') >= 0) {\n      wkbType += this.isEWKB_ ? 0x40000000 : 2000;\n    }\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      wkbType |= 0x20000000;\n    }\n\n    this.writeUint8(this.isLittleEndian_ ? 1 : 0);\n    this.writeUint32(wkbType);\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      this.writeUint32(srid);\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiPoint(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(1);\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiLineString(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(2);\n      this.writeLineString(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiPolygon(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(3);\n      this.writePolygon(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<import('../geom/Geometry.js').default>} geometries geometries\n   */\n  writeGeometryCollection(geometries) {\n    this.writeUint32(geometries.length); // numItems\n\n    for (let i = 0; i < geometries.length; i++) {\n      this.writeGeometry(geometries[i]);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} [layout] layout\n   * @return {import(\"../geom/Geometry.js\").GeometryLayout} minumum layout made by common axes\n   */\n  findMinimumLayout(geom, layout = 'XYZM') {\n    /**\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} a A\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} b B\n     * @return {import(\"../geom/Geometry.js\").GeometryLayout} minumum layout made by common axes\n     */\n    const GeometryLayout_min = (a, b) => {\n      if (a === b) {\n        return a;\n      }\n\n      if (a === 'XYZM') {\n        // anything `b` is minimum\n        return b;\n      }\n      if (b === 'XYZM') {\n        // anything `a` is minimum\n        return a;\n      }\n\n      // otherwise, incompatible\n      return 'XY';\n    };\n\n    if (geom instanceof SimpleGeometry) {\n      return GeometryLayout_min(geom.getLayout(), layout);\n    }\n\n    if (geom instanceof GeometryCollection) {\n      const geoms = geom.getGeometriesArray();\n      for (let i = 0; i < geoms.length && layout !== 'XY'; i++) {\n        layout = this.findMinimumLayout(geoms[i], layout);\n      }\n    }\n\n    return layout;\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {number} [srid] SRID\n   */\n  writeGeometry(geom, srid) {\n    /**\n     * @type {Object<import(\"../geom/Geometry.js\").Type, WKBGeometryType>}\n     */\n    const wkblut = {\n      Point: WKBGeometryType.POINT,\n      LineString: WKBGeometryType.LINE_STRING,\n      Polygon: WKBGeometryType.POLYGON,\n      MultiPoint: WKBGeometryType.MULTI_POINT,\n      MultiLineString: WKBGeometryType.MULTI_LINE_STRING,\n      MultiPolygon: WKBGeometryType.MULTI_POLYGON,\n      GeometryCollection: WKBGeometryType.GEOMETRY_COLLECTION,\n    };\n    const geomType = geom.getType();\n    const typeId = wkblut[geomType];\n\n    if (!typeId) {\n      throw new Error('GeometryType ' + geomType + ' is not supported');\n    }\n\n    // first call of writeGeometry() traverse whole geometries to determine its output layout if not specified on constructor.\n    if (!this.layout_) {\n      this.layout_ = this.findMinimumLayout(geom);\n    }\n\n    this.writeWkbHeader(typeId, srid);\n\n    if (geom instanceof SimpleGeometry) {\n      const writerLUT = {\n        Point: this.writePoint,\n        LineString: this.writeLineString,\n        Polygon: this.writePolygon,\n        MultiPoint: this.writeMultiPoint,\n        MultiLineString: this.writeMultiLineString,\n        MultiPolygon: this.writeMultiPolygon,\n      };\n      writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());\n    } else if (geom instanceof GeometryCollection) {\n      this.writeGeometryCollection(geom.getGeometriesArray());\n    }\n  }\n\n  getBuffer() {\n    const byteLength = this.writeQueue_.reduce((acc, item) => acc + item[0], 0);\n    const buffer = new ArrayBuffer(byteLength);\n    const view = new DataView(buffer);\n\n    let pos = 0;\n    this.writeQueue_.forEach((item) => {\n      switch (item[0]) {\n        case 1:\n          view.setUint8(pos, item[1]);\n          break;\n        case 4:\n          view.setUint32(pos, item[1], this.isLittleEndian_);\n          break;\n        case 8:\n          view.setFloat64(pos, item[1], this.isLittleEndian_);\n          break;\n        default:\n          break;\n      }\n\n      pos += item[0];\n    });\n\n    return buffer;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.\n * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.\n * @property {boolean} [littleEndian=true] Use littleEndian for output.\n * @property {boolean} [ewkb=true] Use EWKB format for output.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)\n * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.\n * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.\n * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.\n */\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.\n * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.\n *\n * @api\n */\nclass WKB extends FeatureFormat {\n  /**\n   * @param {Options} [opt_options] Optional configuration object.\n   */\n  constructor(opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    this.splitCollection = Boolean(options.splitCollection);\n\n    this.viewCache_ = null;\n\n    this.hex_ = options.hex !== false;\n    this.littleEndian_ = options.littleEndian !== false;\n    this.ewkb_ = options.ewkb !== false;\n\n    this.layout_ = options.geometryLayout; // null for auto detect\n    this.nodataZ_ = options.nodataZ || 0;\n    this.nodataM_ = options.nodataM || 0;\n\n    this.srid_ = options.srid;\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return this.hex_ ? 'text' : 'arraybuffer';\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, opt_options) {\n    return new Feature({\n      geometry: this.readGeometry(source, opt_options),\n    });\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, opt_options) {\n    let geometries = [];\n    const geometry = this.readGeometry(source, opt_options);\n    if (this.splitCollection && geometry instanceof GeometryCollection) {\n      geometries = geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    return geometries.map((geometry) => new Feature({geometry}));\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   */\n  readGeometry(source, opt_options) {\n    const view = getDataView(source);\n    if (!view) {\n      return null;\n    }\n\n    const reader = new WkbReader(view);\n    const geometry = reader.readGeometry();\n\n    this.viewCache_ = view; // cache for internal subsequent call of readProjection()\n    const options = this.getReadOptions(source, opt_options);\n    this.viewCache_ = null; // release\n\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   * @api\n   */\n  readProjection(source) {\n    const view = this.viewCache_ || getDataView(source);\n    if (!view) {\n      return undefined;\n    }\n\n    const reader = new WkbReader(view);\n    reader.readWkbHeader();\n\n    return (\n      (reader.getSrid() && getProjection('EPSG:' + reader.getSrid())) ||\n      undefined\n    );\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeature(feature, opt_options) {\n    return this.writeGeometry(feature.getGeometry(), opt_options);\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeatures(features, opt_options) {\n    return this.writeGeometry(\n      new GeometryCollection(features.map((f) => f.getGeometry())),\n      opt_options\n    );\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeGeometry(geometry, opt_options) {\n    const options = this.adaptOptions(opt_options);\n\n    const writer = new WkbWriter({\n      layout: this.layout_,\n      littleEndian: this.littleEndian_,\n      ewkb: this.ewkb_,\n\n      nodata: {\n        Z: this.nodataZ_,\n        M: this.nodataM_,\n      },\n    });\n\n    // extract SRID from `dataProjection`\n    let srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;\n    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {\n      const dataProjection =\n        options.dataProjection && getProjection(options.dataProjection);\n      if (dataProjection) {\n        const code = dataProjection.getCode();\n        if (code.indexOf('EPSG:') === 0) {\n          srid = Number(code.substring(5));\n        }\n      }\n    }\n\n    writer.writeGeometry(\n      transformGeometryWithOptions(geometry, true, options),\n      srid\n    );\n    const buffer = writer.getBuffer();\n\n    return this.hex_ ? encodeHexString(buffer) : buffer;\n  }\n}\n\n/**\n * @param {ArrayBuffer} buffer source buffer\n * @return {string} encoded hex string\n */\nfunction encodeHexString(buffer) {\n  const view = new Uint8Array(buffer);\n  return Array.from(view.values())\n    .map((x) => (x < 16 ? '0' : '') + Number(x).toString(16).toUpperCase())\n    .join('');\n}\n\n/**\n * @param {string} text source text\n * @return {DataView} decoded binary buffer\n */\nfunction decodeHexString(text) {\n  const buffer = new Uint8Array(text.length / 2);\n  for (let i = 0; i < text.length / 2; i++) {\n    buffer[i] = parseInt(text.substr(i * 2, 2), 16);\n  }\n  return new DataView(buffer.buffer);\n}\n\n/**\n * @param {string | ArrayBuffer | ArrayBufferView} source source\n * @return {DataView} data view\n */\nfunction getDataView(source) {\n  if (typeof source === 'string') {\n    return decodeHexString(source);\n  } else if (ArrayBuffer.isView(source)) {\n    if (source instanceof DataView) {\n      return source;\n    }\n    return new DataView(source.buffer, source.byteOffset, source.byteLength);\n  } else if (source instanceof ArrayBuffer) {\n    return new DataView(source);\n  } else {\n    return null;\n  }\n}\n\nexport default WKB;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport WKB from '../src/ol/format/WKB.js';\nimport {OSM, Vector as VectorSource} from '../src/ol/source.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\n\nconst raster = new TileLayer({\n  source: new OSM(),\n});\n\nconst wkb =\n  '0103000000010000000500000054E3A59BC4602540643BDF4F8D1739C05C8FC2F5284C4140EC51B81E852B34C0D578E926316843406F1283C0CAD141C01B2FDD2406012B40A4703D0AD79343C054E3A59BC4602540643BDF4F8D1739C0';\n\nconst format = new WKB();\n\nconst feature = format.readFeature(wkb, {\n  dataProjection: 'EPSG:4326',\n  featureProjection: 'EPSG:3857',\n});\n\nconst vector = new VectorLayer({\n  source: new VectorSource({\n    features: [feature],\n  }),\n});\n\nconst map = new Map({\n  layers: [raster, vector],\n  target: 'map',\n  view: new View({\n    center: [2952104.0199, -3277504.823],\n    zoom: 4,\n  }),\n});\n"],"names":["WKBGeometryType","WkbReader","constructor","view","this","view_","pos_","initialized_","isLittleEndian_","hasZ_","hasM_","srid_","layout_","readUint8","getUint8","readUint32","isLittleEndian","getUint32","undefined","readDouble","getFloat64","readPoint","coords","push","readLineString","numPoints","i","readPolygon","numRings","rings","readWkbHeader","expectedTypeId","wkbType","wkbTypeThousandth","Math","floor","hasZ","Boolean","hasM","hasSRID","typeId","layout","join","srid","Error","readWkbPayload","readMultiPoint","readMultiLineString","readMultiPolygon","readGeometryCollection","readWkbBlock","readWkbCollection","reader","num","items","result","call","readGeometry","Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection","getSrid","WkbWriter","opts","littleEndian","isEWKB_","ewkb","writeQueue_","nodata_","assign","X","Y","Z","M","nodata","writeUint8","value","writeUint32","writeDouble","writePoint","coordsObj","split","map","axis","idx","writeLineString","length","writePolygon","writeWkbHeader","indexOf","Number","isInteger","writeMultiPoint","writeMultiLineString","writeMultiPolygon","writeGeometryCollection","geometries","writeGeometry","findMinimumLayout","geom","SimpleGeometry","a","getLayout","b","geoms","getGeometriesArray","wkblut","geomType","getType","getCoordinates","getBuffer","byteLength","reduce","acc","item","buffer","ArrayBuffer","DataView","pos","forEach","setUint8","setUint32","setFloat64","WKB","FeatureFormat","opt_options","super","options","splitCollection","viewCache_","hex_","hex","littleEndian_","ewkb_","geometryLayout","nodataZ_","nodataZ","nodataM_","nodataM","readFeature","source","Feature","geometry","readFeatures","getDataView","getReadOptions","transformGeometryWithOptions","readProjection","getProjection","writeFeature","feature","getGeometry","writeFeatures","features","f","adaptOptions","writer","dataProjection","code","getCode","substring","Uint8Array","Array","from","values","x","toString","toUpperCase","encodeHexString","text","parseInt","substr","decodeHexString","isView","byteOffset","raster","TileLayer","OSM","featureProjection","vector","VectorLayer","VectorSource","Map","layers","target","View","center","zoom"],"sourceRoot":""}