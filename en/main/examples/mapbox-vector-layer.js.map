{"version":3,"file":"mapbox-vector-layer.js","mappings":"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","sources":["webpack:///../src/ol/layer/MapboxVector.js","webpack:///./mapbox-vector-layer.js"],"sourcesContent":["/**\n * @module ol/layer/MapboxVector\n */\nimport BaseEvent from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport MVT from '../format/MVT.js';\nimport RenderFeature from '../render/Feature.js';\nimport SourceState from '../source/State.js';\nimport TileEventType from '../source/TileEventType.js';\nimport VectorTileLayer from '../layer/VectorTile.js';\nimport VectorTileSource from '../source/VectorTile.js';\nimport {Fill, Style} from '../style.js';\nimport {applyStyle, setupVectorSource} from 'ol-mapbox-style';\nimport {fromExtent} from '../geom/Polygon.js';\nimport {getValue} from 'ol-mapbox-style/dist/stylefunction.js';\n\nconst mapboxBaseUrl = 'https://api.mapbox.com';\n\n/**\n * Gets the path from a mapbox:// URL.\n * @param {string} url The Mapbox URL.\n * @return {string} The path.\n * @private\n */\nexport function getMapboxPath(url) {\n  const startsWith = 'mapbox://';\n  if (url.indexOf(startsWith) !== 0) {\n    return '';\n  }\n  return url.slice(startsWith.length);\n}\n\n/**\n * Turns mapbox:// sprite URLs into resolvable URLs.\n * @param {string} url The sprite URL.\n * @param {string} token The access token.\n * @param {string} styleUrl The style URL.\n * @return {string} A resolvable URL.\n * @private\n */\nexport function normalizeSpriteUrl(url, token, styleUrl) {\n  const mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    return decodeURI(new URL(url, styleUrl).href);\n  }\n  const startsWith = 'sprites/';\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(`unexpected sprites url: ${url}`);\n  }\n  const sprite = mapboxPath.slice(startsWith.length);\n\n  return `${mapboxBaseUrl}/styles/v1/${sprite}/sprite?access_token=${token}`;\n}\n\n/**\n * Turns mapbox:// glyphs URLs into resolvable URLs.\n * @param {string} url The glyphs URL.\n * @param {string} token The access token.\n * @param {string} styleUrl The style URL.\n * @return {string} A resolvable URL.\n * @private\n */\nexport function normalizeGlyphsUrl(url, token, styleUrl) {\n  const mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    return decodeURI(new URL(url, styleUrl).href);\n  }\n  const startsWith = 'fonts/';\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(`unexpected fonts url: ${url}`);\n  }\n  const font = mapboxPath.slice(startsWith.length);\n\n  return `${mapboxBaseUrl}/fonts/v1/${font}/0-255.pbf?access_token=${token}`;\n}\n\n/**\n * Turns mapbox:// style URLs into resolvable URLs.\n * @param {string} url The style URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\nexport function normalizeStyleUrl(url, token) {\n  const mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    return decodeURI(new URL(url, location.href).href);\n  }\n  const startsWith = 'styles/';\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(`unexpected style url: ${url}`);\n  }\n  const style = mapboxPath.slice(startsWith.length);\n\n  return `${mapboxBaseUrl}/styles/v1/${style}?&access_token=${token}`;\n}\n\n/**\n * Turns mapbox:// source URLs into vector tile URL templates.\n * @param {string} url The source URL.\n * @param {string} token The access token.\n * @param {string} tokenParam The access token key.\n * @param {string} styleUrl The style URL.\n * @return {string} A vector tile template.\n * @private\n */\nexport function normalizeSourceUrl(url, token, tokenParam, styleUrl) {\n  const urlObject = new URL(url, styleUrl);\n  const mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    if (!token) {\n      return decodeURI(urlObject.href);\n    }\n    urlObject.searchParams.set(tokenParam, token);\n    return decodeURI(urlObject.href);\n  }\n  return `https://{a-d}.tiles.mapbox.com/v4/${mapboxPath}/{z}/{x}/{y}.vector.pbf?access_token=${token}`;\n}\n\n/**\n * @classdesc\n * Event emitted on configuration or loading error.\n */\nclass ErrorEvent extends BaseEvent {\n  /**\n   * @param {Error} error error object.\n   */\n  constructor(error) {\n    super(EventType.ERROR);\n\n    /**\n     * @type {Error}\n     */\n    this.error = error;\n  }\n}\n\n/**\n * @typedef {Object} StyleObject\n * @property {Object<string, SourceObject>} sources The style sources.\n * @property {string} sprite The sprite URL.\n * @property {string} glyphs The glyphs URL.\n * @property {Array<LayerObject>} layers The style layers.\n */\n\n/**\n * @typedef {Object} SourceObject\n * @property {string} url The source URL.\n * @property {SourceType} type The source type.\n * @property {Array<string>} [tiles] TileJSON tiles.\n */\n\n/**\n * The Mapbox source type.\n * @enum {string}\n */\nconst SourceType = {\n  VECTOR: 'vector',\n};\n\n/**\n * @typedef {Object} LayerObject\n * @property {string} id The layer id.\n * @property {string} type The layer type.\n * @property {string} source The source id.\n * @property {Object} layout The layout.\n * @property {Object} paint The paint.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} styleUrl The URL of the Mapbox style object to use for this layer.  For a\n * style created with Mapbox Studio and hosted on Mapbox, this will look like\n * 'mapbox://styles/you/your-style'.\n * @property {string} [accessToken] The access token for your Mapbox style. This has to be provided\n * for `mapbox://` style urls. For `https://` and other urls, any access key must be the last query\n * parameter of the style url.\n * @property {string} [source] If your style uses more than one source, you need to use either the\n * `source` property or the `layers` property to limit rendering to a single vector source.  The\n * `source` property corresponds to the id of a vector source in your Mapbox style.\n * @property {Array<string>} [layers] Limit rendering to the list of included layers.  All layers\n * must share the same vector source.  If your style uses more than one source, you need to use\n * either the `source` property or the `layers` property to limit rendering to a single vector\n * source.\n * @property {boolean} [declutter=true] Declutter images and text. Decluttering is applied to all\n * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority\n * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.\n * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has\n * higher priority.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible. If neither `maxResolution` nor `minZoom` are defined, the layer's `maxResolution` will\n * match the style source's `minzoom`.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will\n * be visible. If neither `maxResolution` nor `minZoom` are defined, the layer's `minZoom` will match\n * the style source's `minzoom`.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the\n * renderer when getting features from the vector tile for the rendering or hit-detection.\n * Recommended value: Vector tiles are usually generated with a buffer, so this value should match\n * the largest possible buffer of the used tiles. It should be at least the size of the largest\n * point symbol or line width.\n * @property {import(\"./VectorTileRenderType.js\").default|string} [renderMode='hybrid'] Render mode for vector tiles:\n *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom\n *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on\n *    rotated views.\n *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector\n *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of\n *    another layer with the same source).\n * @property {import(\"../PluggableMap.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../PluggableMap.js\").default#addLayer map.addLayer()}.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be\n * recreated during animations. This means that no vectors will be shown clipped, but the setting\n * will have a performance impact for large amounts of vector data. When set to `false`, batches\n * will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be\n * recreated during interactions. See also `updateWhileAnimating`.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * A vector tile layer based on a Mapbox style that uses a single vector source.  Configure\n * the layer with the `styleUrl` and `accessToken` shown in Mapbox Studio's share panel.\n * If the style uses more than one source, use the `source` property to choose a single\n * vector source.  If you want to render a subset of the layers in the style, use the `layers`\n * property (all layers must share the same vector source).  See the constructor options for\n * more detail.\n *\n *     var map = new Map({\n *       view: new View({\n *         center: [0, 0],\n *         zoom: 1\n *       }),\n *       layers: [\n *         new MapboxVectorLayer({\n *           styleUrl: 'mapbox://styles/mapbox/bright-v9',\n *           accessToken: 'your-mapbox-access-token-here'\n *         })\n *       ],\n *       target: 'map'\n *     });\n *\n * On configuration or loading error, the layer will trigger an `'error'` event.  Listeners\n * will receive an object with an `error` property that can be used to diagnose the problem.\n *\n * @param {Options} options Options.\n * @extends {VectorTileLayer}\n * @fires module:ol/events/Event~BaseEvent#event:error\n * @api\n */\nclass MapboxVectorLayer extends VectorTileLayer {\n  /**\n   * @param {Options} options Layer options.  At a minimum, `styleUrl` and `accessToken`\n   * must be provided.\n   */\n  constructor(options) {\n    const declutter = 'declutter' in options ? options.declutter : true;\n    const source = new VectorTileSource({\n      state: SourceState.LOADING,\n      format: new MVT(),\n    });\n\n    super({\n      source: source,\n      declutter: declutter,\n      className: options.className,\n      opacity: options.opacity,\n      visible: options.visible,\n      zIndex: options.zIndex,\n      minResolution: options.minResolution,\n      maxResolution: options.maxResolution,\n      minZoom: options.minZoom,\n      maxZoom: options.maxZoom,\n      renderOrder: options.renderOrder,\n      renderBuffer: options.renderBuffer,\n      renderMode: options.renderMode,\n      map: options.map,\n      updateWhileAnimating: options.updateWhileAnimating,\n      updateWhileInteracting: options.updateWhileInteracting,\n      preload: options.preload,\n      useInterimTilesOnError: options.useInterimTilesOnError,\n      properties: options.properties,\n    });\n\n    this.setMaxResolutionFromTileGrid_ =\n      options.maxResolution === undefined && options.minZoom === undefined;\n\n    this.sourceId = options.source;\n    this.layers = options.layers;\n\n    if (options.accessToken) {\n      this.accessToken = options.accessToken;\n    } else {\n      const url = new URL(options.styleUrl, location.href);\n      // The last search parameter is the access token\n      url.searchParams.forEach((value, key) => {\n        this.accessToken = value;\n        this.accessTokenParam_ = key;\n      });\n    }\n    this.fetchStyle(options.styleUrl);\n  }\n\n  /**\n   * Fetch the style object.\n   * @param {string} styleUrl The URL of the style to load.\n   * @protected\n   */\n  fetchStyle(styleUrl) {\n    const url = normalizeStyleUrl(styleUrl, this.accessToken);\n    fetch(url)\n      .then((response) => {\n        if (!response.ok) {\n          throw new Error(\n            `unexpected response when fetching style: ${response.status}`\n          );\n        }\n        return response.json();\n      })\n      .then((style) => {\n        this.onStyleLoad(style, url.startsWith('data:') ? location.href : url);\n      })\n      .catch((error) => {\n        this.handleError(error);\n      });\n  }\n\n  /**\n   * Handle the loaded style object.\n   * @param {StyleObject} style The loaded style.\n   * @param {string} styleUrl The URL of the style.\n   * @protected\n   */\n  onStyleLoad(style, styleUrl) {\n    let sourceId;\n    let sourceIdOrLayersList;\n    if (this.layers) {\n      // confirm all layers share the same source\n      const lookup = {};\n      for (let i = 0; i < style.layers.length; ++i) {\n        const layer = style.layers[i];\n        if (layer.source) {\n          lookup[layer.id] = layer.source;\n        }\n      }\n      let firstSource;\n      for (let i = 0; i < this.layers.length; ++i) {\n        const candidate = lookup[this.layers[i]];\n        if (!candidate) {\n          this.handleError(\n            new Error(`could not find source for ${this.layers[i]}`)\n          );\n          return;\n        }\n        if (!firstSource) {\n          firstSource = candidate;\n        } else if (firstSource !== candidate) {\n          this.handleError(\n            new Error(\n              `layers can only use a single source, found ${firstSource} and ${candidate}`\n            )\n          );\n          return;\n        }\n      }\n      sourceId = firstSource;\n      sourceIdOrLayersList = this.layers;\n    } else {\n      sourceId = this.sourceId;\n      sourceIdOrLayersList = sourceId;\n    }\n\n    if (!sourceIdOrLayersList) {\n      // default to the first source in the style\n      sourceId = Object.keys(style.sources)[0];\n      sourceIdOrLayersList = sourceId;\n    }\n\n    if (style.sprite) {\n      style.sprite = normalizeSpriteUrl(\n        style.sprite,\n        this.accessToken,\n        styleUrl\n      );\n    }\n\n    if (style.glyphs) {\n      style.glyphs = normalizeGlyphsUrl(\n        style.glyphs,\n        this.accessToken,\n        styleUrl\n      );\n    }\n\n    const styleSource = style.sources[sourceId];\n    if (styleSource.type !== SourceType.VECTOR) {\n      this.handleError(\n        new Error(`only works for vector sources, found ${styleSource.type}`)\n      );\n      return;\n    }\n\n    const source = this.getSource();\n    if (styleSource.url && styleSource.url.indexOf('mapbox://') === 0) {\n      // Tile source url, handle it directly\n      source.setUrl(\n        normalizeSourceUrl(\n          styleSource.url,\n          this.accessToken,\n          this.accessTokenParam_,\n          styleUrl\n        )\n      );\n      applyStyle(this, style, sourceIdOrLayersList)\n        .then(() => {\n          this.configureSource(source, style);\n        })\n        .catch((error) => {\n          this.handleError(error);\n        });\n    } else {\n      // TileJSON url, let ol-mapbox-style handle it\n      if (styleSource.tiles) {\n        styleSource.tiles = styleSource.tiles.map((url) =>\n          normalizeSourceUrl(\n            url,\n            this.accessToken,\n            this.accessTokenParam_,\n            styleUrl\n          )\n        );\n      }\n      setupVectorSource(\n        styleSource,\n        styleSource.url\n          ? normalizeSourceUrl(\n              styleSource.url,\n              this.accessToken,\n              this.accessTokenParam_,\n              styleUrl\n            )\n          : undefined\n      ).then((source) => {\n        applyStyle(this, style, sourceIdOrLayersList)\n          .then(() => {\n            this.configureSource(source, style);\n          })\n          .catch((error) => {\n            this.configureSource(source, style);\n            this.handleError(error);\n          });\n      });\n    }\n  }\n\n  /**\n   * Applies configuration from the provided source to this layer's source,\n   * and reconfigures the loader to add a feature that renders the background,\n   * if the style is configured with a background.\n   * @param {import(\"../source/VectorTile.js\").default} source The source to configure from.\n   * @param {StyleObject} style The style to configure the background from.\n   */\n  configureSource(source, style) {\n    const targetSource = this.getSource();\n    if (source !== targetSource) {\n      targetSource.setAttributions(source.getAttributions());\n      targetSource.setTileUrlFunction(source.getTileUrlFunction());\n      targetSource.setTileLoadFunction(source.getTileLoadFunction());\n      targetSource.tileGrid = source.tileGrid;\n    }\n    const background = style.layers.find(\n      (layer) => layer.type === 'background'\n    );\n    if (\n      background &&\n      (!background.layout || background.layout.visibility !== 'none')\n    ) {\n      const style = new Style({\n        fill: new Fill(),\n      });\n      targetSource.addEventListener(TileEventType.TILELOADEND, (event) => {\n        const tile = /** @type {import(\"../VectorTile.js\").default} */ (\n          /** @type {import(\"../source/Tile.js\").TileSourceEvent} */ (event)\n            .tile\n        );\n        const styleFuntion = () => {\n          const opacity =\n            /** @type {number} */ (\n              getValue(\n                background,\n                'paint',\n                'background-opacity',\n                tile.tileCoord[0]\n              )\n            ) || 1;\n          const color = /** @type {*} */ (\n            getValue(background, 'paint', 'background-color', tile.tileCoord[0])\n          );\n          style\n            .getFill()\n            .setColor([\n              color.r * 255,\n              color.g * 255,\n              color.b * 255,\n              color.a * opacity,\n            ]);\n          return style;\n        };\n        const extentGeometry = fromExtent(\n          targetSource.tileGrid.getTileCoordExtent(tile.tileCoord)\n        );\n        const renderFeature = new RenderFeature(\n          GeometryType.POLYGON,\n          extentGeometry.getFlatCoordinates(),\n          extentGeometry.getEnds(),\n          {layer: background.id},\n          undefined\n        );\n        renderFeature.styleFunction = styleFuntion;\n        tile.getFeatures().unshift(renderFeature);\n      });\n    }\n    if (this.setMaxResolutionFromTileGrid_) {\n      const tileGrid = targetSource.getTileGrid();\n      this.setMaxResolution(tileGrid.getResolution(tileGrid.getMinZoom()));\n    }\n    targetSource.setState(SourceState.READY);\n  }\n\n  /**\n   * Handle configuration or loading error.\n   * @param {Error} error The error.\n   * @protected\n   */\n  handleError(error) {\n    this.dispatchEvent(new ErrorEvent(error));\n    const source = this.getSource();\n    source.setState(SourceState.ERROR);\n  }\n}\n\nexport default MapboxVectorLayer;\n","import Map from '../src/ol/Map.js';\nimport MapboxVector from '../src/ol/layer/MapboxVector.js';\nimport View from '../src/ol/View.js';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new MapboxVector({\n      styleUrl: 'mapbox://styles/mapbox/bright-v9',\n      accessToken:\n        'pk.eyJ1IjoiYWhvY2V2YXIiLCJhIjoiY2t0cGdwMHVnMGdlbzMxbDhwazBic2xrNSJ9.WbcTL9uj8JPAsnT9mgb7oQ',\n    }),\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2,\n  }),\n});\n"],"names":["mapboxBaseUrl","getMapboxPath","url","startsWith","indexOf","slice","length","normalizeSourceUrl","token","tokenParam","styleUrl","urlObject","URL","mapboxPath","searchParams","set","decodeURI","href","ErrorEvent","error","EventType","BaseEvent","SourceType","MapboxVectorLayer","options","declutter","source","VectorTileSource","state","SourceState","format","MVT","className","opacity","visible","zIndex","minResolution","maxResolution","minZoom","maxZoom","renderOrder","renderBuffer","renderMode","map","updateWhileAnimating","updateWhileInteracting","preload","useInterimTilesOnError","properties","setMaxResolutionFromTileGrid_","undefined","sourceId","layers","accessToken","location","forEach","value","key","accessTokenParam_","fetchStyle","Error","style","normalizeStyleUrl","this","fetch","then","response","ok","status","json","onStyleLoad","catch","handleError","sourceIdOrLayersList","firstSource","lookup","i","layer","id","candidate","Object","keys","sources","sprite","normalizeSpriteUrl","glyphs","font","normalizeGlyphsUrl","styleSource","type","getSource","setUrl","applyStyle","configureSource","tiles","setupVectorSource","targetSource","setAttributions","getAttributions","setTileUrlFunction","getTileUrlFunction","setTileLoadFunction","getTileLoadFunction","tileGrid","background","find","layout","visibility","Style","fill","Fill","addEventListener","TileEventType","event","tile","extentGeometry","fromExtent","getTileCoordExtent","tileCoord","renderFeature","RenderFeature","GeometryType","getFlatCoordinates","getEnds","styleFunction","getValue","color","getFill","setColor","r","g","b","a","getFeatures","unshift","getTileGrid","setMaxResolution","getResolution","getMinZoom","setState","dispatchEvent","VectorTileLayer","Map","target","MapboxVector","view","View","center","zoom"],"sourceRoot":""}