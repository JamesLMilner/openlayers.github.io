{"version":3,"file":"webgl-vector-tiles.js","mappings":"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","sources":["webpack:///../src/ol/webgl/TileGeometry.js","webpack:///../src/ol/renderer/webgl/VectorTileLayer.js","webpack:///./webgl-vector-tiles.js"],"sourcesContent":["/**\n * @module ol/webgl/TileGeometry\n */\n\nimport BaseTileRepresentation from './BaseTileRepresentation.js';\nimport MixedGeometryBatch from '../render/webgl/MixedGeometryBatch.js';\nimport {\n  create as createTransform,\n  reset as resetTransform,\n  translate as translateTransform,\n} from '../transform.js';\n\n/**\n * @typedef {import(\"../VectorRenderTile\").default} TileType\n */\n\n/**\n * @extends {BaseTileRepresentation<TileType>}\n */\nclass TileGeometry extends BaseTileRepresentation {\n  batch = new MixedGeometryBatch();\n\n  /**\n   * @param {import(\"./BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options The tile texture options.\n   * @param {import(\"../render/webgl/PolygonBatchRenderer.js\").default} polygonRenderer Polygon renderer\n   * @param {import(\"../render/webgl/LineStringBatchRenderer.js\").default} lineStringRenderer Linestring renderer\n   * @param {import(\"../render/webgl/PointBatchRenderer.js\").default} pointRenderer Point renderer\n   */\n  constructor(options, polygonRenderer, lineStringRenderer, pointRenderer) {\n    super(options);\n    /**\n     * @private\n     */\n    this.polygonRenderer_ = polygonRenderer;\n    /**\n     * @private\n     */\n    this.lineStringRenderer_ = lineStringRenderer;\n    /**\n     * @private\n     */\n    this.pointRenderer_ = pointRenderer;\n\n    /**\n     * @private\n     */\n    this.renderInstructionsTransform_ = createTransform();\n\n    this.setTile(options.tile);\n  }\n\n  uploadTile() {\n    this.batch.clear();\n    const sourceTiles = this.tile.getSourceTiles();\n    const features = sourceTiles.reduce(\n      (accumulator, sourceTile) => accumulator.concat(sourceTile.getFeatures()),\n      []\n    );\n    this.batch.addFeatures(features);\n\n    const tileOriginX = sourceTiles[0].extent[0];\n    const tileOriginY = sourceTiles[0].extent[1];\n    resetTransform(this.renderInstructionsTransform_);\n    translateTransform(\n      this.renderInstructionsTransform_,\n      -tileOriginX,\n      -tileOriginY\n    );\n\n    let remaining = 3;\n    const rebuildCb = () => {\n      remaining--;\n      if (remaining === 0) {\n        this.setReady();\n      }\n    };\n\n    // split geometry processing into separate tasks to avoid blocking the UI thread\n    setTimeout(() => {\n      this.polygonRenderer_.rebuild(\n        this.batch.polygonBatch,\n        this.renderInstructionsTransform_,\n        'Polygon',\n        rebuildCb\n      );\n    });\n    setTimeout(() => {\n      this.lineStringRenderer_.rebuild(\n        this.batch.lineStringBatch,\n        this.renderInstructionsTransform_,\n        'LineString',\n        rebuildCb\n      );\n    });\n    setTimeout(() => {\n      this.pointRenderer_.rebuild(\n        this.batch.pointBatch,\n        this.renderInstructionsTransform_,\n        'Point',\n        rebuildCb\n      );\n    });\n  }\n}\n\nexport default TileGeometry;\n","/**\n * @module ol/renderer/webgl/VectorTileLayer\n */\nimport EventType from '../../events/EventType.js';\nimport LineStringBatchRenderer from '../../render/webgl/LineStringBatchRenderer.js';\nimport PointBatchRenderer from '../../render/webgl/PointBatchRenderer.js';\nimport PolygonBatchRenderer from '../../render/webgl/PolygonBatchRenderer.js';\nimport TileGeometry from '../../webgl/TileGeometry.js';\nimport WebGLBaseTileLayerRenderer, {Uniforms} from './TileLayerBase.js';\nimport {\n  FILL_FRAGMENT_SHADER,\n  FILL_VERTEX_SHADER,\n  POINT_FRAGMENT_SHADER,\n  POINT_VERTEX_SHADER,\n  STROKE_FRAGMENT_SHADER,\n  STROKE_VERTEX_SHADER,\n} from './shaders.js';\nimport {\n  create as createMat4,\n  fromTransform as mat4FromTransform,\n} from '../../vec/mat4.js';\nimport {\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  setFromArray as setFromTransform,\n} from '../../transform.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {getIntersection} from '../../extent.js';\nimport {packColor} from '../../webgl/styleparser.js';\n\n/**\n * @param {Object<import(\"./shaders.js\").DefaultAttributes,CustomAttributeCallback>} obj Lookup of attribute getters.\n * @return {Array<import(\"../../render/webgl/BatchRenderer\").CustomAttribute>} An array of attribute descriptors.\n */\nfunction toAttributesArray(obj) {\n  return Object.keys(obj).map((key) => ({\n    name: key,\n    size: key === 'color' ? 2 : 1,\n    callback: obj[key],\n  }));\n}\n\n/**\n * @typedef {function(import(\"../../Feature\").default, Object<string, *>):number} CustomAttributeCallback A callback computing\n * the value of a custom attribute (different for each feature) to be passed on to the GPU.\n * Properties are available as 2nd arg for quicker access.\n */\n\n/**\n * @typedef {Object} ShaderProgram An object containing both shaders (vertex and fragment) as well as the required attributes\n * @property {string} [vertexShader] Vertex shader source (using the default one if unspecified).\n * @property {string} [fragmentShader] Fragment shader source (using the default one if unspecified).\n * @property {Object<import(\"./shaders.js\").DefaultAttributes,CustomAttributeCallback>} attributes Custom attributes made available in the vertex shader.\n * Keys are the names of the attributes which are then accessible in the vertex shader using the `a_` prefix, e.g.: `a_opacity`.\n * Default shaders rely on the attributes in {@link module:ol/render/webgl/shaders~DefaultAttributes}.\n */\n\n/**\n * @typedef {Object} Options\n * @property {ShaderProgram} [fill] Attributes and shaders for filling polygons.\n * @property {ShaderProgram} [stroke] Attributes and shaders for line strings and polygon strokes.\n * @property {ShaderProgram} [point] Attributes and shaders for points.\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {number} [cacheSize=512] The vector tile cache size.\n */\n\n/**\n * @typedef {import(\"../../layer/BaseTile.js\").default} LayerType\n */\n\n/**\n * @classdesc\n * WebGL renderer for vector tile layers. Experimental.\n * @extends {WebGLBaseTileLayerRenderer<LayerType>}\n */\nclass WebGLVectorTileLayerRenderer extends WebGLBaseTileLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, options);\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    /**\n     * @type {PolygonBatchRenderer}\n     * @private\n     */\n    this.polygonRenderer_ = null;\n    /**\n     * @type {PointBatchRenderer}\n     * @private\n     */\n    this.pointRenderer_ = null;\n    /**\n     * @type {LineStringBatchRenderer}\n     * @private\n     */\n    this.lineStringRenderer_ = null;\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentFrameStateTransform_ = createTransform();\n\n    this.tmpTransform_ = createTransform();\n    this.tmpMat4_ = createMat4();\n\n    this.applyOptions_(options);\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset(options);\n\n    this.applyOptions_(options);\n    if (this.helper) {\n      this.createRenderers_();\n    }\n  }\n\n  /**\n   * @param {Options} options Options.\n   * @private\n   */\n  applyOptions_(options) {\n    const fillAttributes = {\n      color: function () {\n        return packColor('#ddd');\n      },\n      ...(options.fill && options.fill.attributes),\n    };\n\n    const strokeAttributes = {\n      color: function () {\n        return packColor('#eee');\n      },\n      width: function () {\n        return 1.5;\n      },\n      ...(options.stroke && options.stroke.attributes),\n    };\n\n    const pointAttributes = {\n      color: function () {\n        return packColor('#eee');\n      },\n      ...(options.point && options.point.attributes),\n    };\n\n    this.fillVertexShader_ =\n      (options.fill && options.fill.vertexShader) || FILL_VERTEX_SHADER;\n    this.fillFragmentShader_ =\n      (options.fill && options.fill.fragmentShader) || FILL_FRAGMENT_SHADER;\n    this.fillAttributes_ = toAttributesArray(fillAttributes);\n\n    this.strokeVertexShader_ =\n      (options.stroke && options.stroke.vertexShader) || STROKE_VERTEX_SHADER;\n    this.strokeFragmentShader_ =\n      (options.stroke && options.stroke.fragmentShader) ||\n      STROKE_FRAGMENT_SHADER;\n    this.strokeAttributes_ = toAttributesArray(strokeAttributes);\n\n    this.pointVertexShader_ =\n      (options.point && options.point.vertexShader) || POINT_VERTEX_SHADER;\n    this.pointFragmentShader_ =\n      (options.point && options.point.fragmentShader) || POINT_FRAGMENT_SHADER;\n    this.pointAttributes_ = toAttributesArray(pointAttributes);\n  }\n\n  /**\n   * @private\n   */\n  createRenderers_() {\n    this.polygonRenderer_ = new PolygonBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.fillVertexShader_,\n      this.fillFragmentShader_,\n      this.fillAttributes_\n    );\n    this.pointRenderer_ = new PointBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.pointVertexShader_,\n      this.pointFragmentShader_,\n      this.pointAttributes_\n    );\n    this.lineStringRenderer_ = new LineStringBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.strokeVertexShader_,\n      this.strokeFragmentShader_,\n      this.strokeAttributes_\n    );\n  }\n\n  afterHelperCreated() {\n    this.createRenderers_();\n  }\n\n  createTileRepresentation(options) {\n    const tileRep = new TileGeometry(\n      options,\n      this.polygonRenderer_,\n      this.lineStringRenderer_,\n      this.pointRenderer_\n    );\n    // redraw the layer when the tile is ready\n    const listener = () => {\n      if (tileRep.ready) {\n        this.getLayer().changed();\n        tileRep.removeEventListener(EventType.CHANGE, listener);\n      }\n    };\n    tileRep.addEventListener(EventType.CHANGE, listener);\n    return tileRep;\n  }\n\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    super.beforeTilesRender(frameState, true); // always consider that tiles need alpha blending\n    this.helper.makeProjectionTransform(\n      frameState,\n      this.currentFrameStateTransform_\n    );\n  }\n\n  /**\n   * @param {number} alpha Alpha value of the tile\n   * @param {import(\"../../extent.js\").Extent} renderExtent Which extent to restrict drawing to\n   * @param {import(\"../../transform.js\").Transform} batchInvertTransform Inverse of the transformation in which tile geometries are expressed\n   * @private\n   */\n  applyUniforms_(alpha, renderExtent, batchInvertTransform) {\n    // world to screen matrix\n    setFromTransform(this.tmpTransform_, this.currentFrameStateTransform_);\n    multiplyTransform(this.tmpTransform_, batchInvertTransform);\n    this.helper.setUniformMatrixValue(\n      Uniforms.PROJECTION_MATRIX,\n      mat4FromTransform(this.tmpMat4_, this.tmpTransform_)\n    );\n\n    // screen to world matrix\n    makeInverseTransform(this.tmpTransform_, this.currentFrameStateTransform_);\n    this.helper.setUniformMatrixValue(\n      Uniforms.SCREEN_TO_WORLD_MATRIX,\n      mat4FromTransform(this.tmpMat4_, this.tmpTransform_)\n    );\n\n    this.helper.setUniformFloatValue(Uniforms.GLOBAL_ALPHA, alpha);\n    this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, renderExtent);\n  }\n\n  renderTile(\n    tileRepresentation,\n    tileTransform,\n    frameState,\n    renderExtent,\n    tileResolution,\n    tileSize,\n    tileOrigin,\n    tileExtent,\n    depth,\n    gutter,\n    alpha\n  ) {\n    const gutterExtent = getIntersection(tileExtent, renderExtent, tileExtent);\n\n    this.polygonRenderer_.preRender(\n      tileRepresentation.batch.polygonBatch,\n      this.frameState\n    );\n    this.applyUniforms_(\n      alpha,\n      gutterExtent,\n      tileRepresentation.batch.polygonBatch.invertVerticesBufferTransform\n    );\n    this.polygonRenderer_.render(tileRepresentation.batch.polygonBatch);\n\n    this.lineStringRenderer_.preRender(\n      tileRepresentation.batch.lineStringBatch,\n      this.frameState\n    );\n    this.applyUniforms_(\n      alpha,\n      gutterExtent,\n      tileRepresentation.batch.lineStringBatch.invertVerticesBufferTransform\n    );\n    this.lineStringRenderer_.render(tileRepresentation.batch.lineStringBatch);\n\n    this.pointRenderer_.preRender(\n      tileRepresentation.batch.pointBatch,\n      this.frameState\n    );\n    this.applyUniforms_(\n      alpha,\n      gutterExtent,\n      tileRepresentation.batch.pointBatch.invertVerticesBufferTransform\n    );\n    this.pointRenderer_.render(tileRepresentation.batch.pointBatch);\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {}\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLVectorTileLayerRenderer;\n","import MVT from '../src/ol/format/MVT.js';\nimport Map from '../src/ol/Map.js';\nimport VectorTile from '../src/ol/layer/VectorTile.js';\nimport VectorTileSource from '../src/ol/source/VectorTile.js';\nimport View from '../src/ol/View.js';\nimport WebGLVectorTileLayerRenderer from '../src/ol/renderer/webgl/VectorTileLayer.js';\nimport {Fill, Icon, Stroke, Style, Text} from '../src/ol/style.js';\nimport {asArray} from '../src/ol/color.js';\nimport {packColor} from '../src/ol/webgl/styleparser.js';\n\nconst key =\n  'pk.eyJ1IjoiYWhvY2V2YXIiLCJhIjoiY2t0cGdwMHVnMGdlbzMxbDhwazBic2xrNSJ9.WbcTL9uj8JPAsnT9mgb7oQ';\n\nclass WebGLVectorTileLayer extends VectorTile {\n  createRenderer() {\n    return new WebGLVectorTileLayerRenderer(this, {\n      fill: {\n        attributes: {\n          color: (feature) => {\n            const style = this.getStyle()(feature, 1)[0];\n            const color = asArray(style?.getFill()?.getColor() || '#eee');\n            return packColor(color);\n          },\n        },\n      },\n      stroke: {\n        attributes: {\n          color: (feature) => {\n            const style = this.getStyle()(feature, 1)[0];\n            const color = asArray(style?.getStroke()?.getColor() || '#eee');\n            return packColor(color);\n          },\n          width: (feature) => {\n            const style = this.getStyle()(feature, 1)[0];\n            return style?.getStroke()?.getWidth() || 0;\n          },\n        },\n      },\n      point: {\n        attributes: {\n          color: () => packColor(asArray('#777')),\n        },\n      },\n    });\n  }\n}\n\nconst map = new Map({\n  layers: [\n    new WebGLVectorTileLayer({\n      source: new VectorTileSource({\n        attributions:\n          '© <a href=\"https://www.mapbox.com/map-feedback/\">Mapbox</a> ' +\n          '© <a href=\"https://www.openstreetmap.org/copyright\">' +\n          'OpenStreetMap contributors</a>',\n        format: new MVT(),\n        url:\n          'https://{a-d}.tiles.mapbox.com/v4/mapbox.mapbox-streets-v6/' +\n          '{z}/{x}/{y}.vector.pbf?access_token=' +\n          key,\n      }),\n      style: createMapboxStreetsV6Style(Style, Fill, Stroke, Icon, Text),\n    }),\n  ],\n  target: 'map',\n  view: new View({\n    center: [0, 0],\n    zoom: 2,\n  }),\n});\n"],"names":["TileGeometry","BaseTileRepresentation","batch","MixedGeometryBatch","constructor","options","polygonRenderer","lineStringRenderer","pointRenderer","super","this","polygonRenderer_","lineStringRenderer_","pointRenderer_","renderInstructionsTransform_","setTile","tile","uploadTile","clear","sourceTiles","getSourceTiles","features","reduce","accumulator","sourceTile","concat","getFeatures","addFeatures","tileOriginX","extent","tileOriginY","remaining","rebuildCb","setReady","setTimeout","rebuild","polygonBatch","lineStringBatch","pointBatch","toAttributesArray","obj","Object","keys","map","key","name","size","callback","WebGLVectorTileLayerRenderer","tileLayer","worker_","currentFrameStateTransform_","tmpTransform_","tmpMat4_","applyOptions_","reset","helper","createRenderers_","fillAttributes","color","fill","attributes","strokeAttributes","width","stroke","pointAttributes","point","fillVertexShader_","vertexShader","fillFragmentShader_","fragmentShader","fillAttributes_","strokeVertexShader_","strokeFragmentShader_","strokeAttributes_","pointVertexShader_","pointFragmentShader_","pointAttributes_","PolygonBatchRenderer","PointBatchRenderer","LineStringBatchRenderer","afterHelperCreated","createTileRepresentation","tileRep","listener","ready","getLayer","changed","removeEventListener","EventType","addEventListener","beforeTilesRender","frameState","tilesWithAlpha","makeProjectionTransform","applyUniforms_","alpha","renderExtent","batchInvertTransform","setUniformMatrixValue","mat4","setUniformFloatValue","setUniformFloatVec4","renderTile","tileRepresentation","tileTransform","tileResolution","tileSize","tileOrigin","tileExtent","depth","gutter","gutterExtent","preRender","invertVerticesBufferTransform","render","renderDeclutter","disposeInternal","terminate","WebGLVectorTileLayer","VectorTile","createRenderer","feature","style","getStyle","getFill","getColor","getStroke","getWidth","Map","layers","source","attributions","format","MVT","url","createMapboxStreetsV6Style","Style","Fill","Stroke","Icon","Text","target","view","View","center","zoom"],"sourceRoot":""}