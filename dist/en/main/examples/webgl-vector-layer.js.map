{"version":3,"file":"webgl-vector-layer.js","mappings":"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","sources":["webpack:///../src/ol/renderer/webgl/VectorLayer.js","webpack:///./webgl-vector-layer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/VectorLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport LineStringBatchRenderer from '../../render/webgl/LineStringBatchRenderer.js';\nimport MixedGeometryBatch from '../../render/webgl/MixedGeometryBatch.js';\nimport PointBatchRenderer from '../../render/webgl/PointBatchRenderer.js';\nimport PolygonBatchRenderer from '../../render/webgl/PolygonBatchRenderer.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {DefaultUniform} from '../../webgl/Helper.js';\nimport {\n  FILL_FRAGMENT_SHADER,\n  FILL_VERTEX_SHADER,\n  POINT_FRAGMENT_SHADER,\n  POINT_VERTEX_SHADER,\n  STROKE_FRAGMENT_SHADER,\n  STROKE_VERTEX_SHADER,\n} from './shaders.js';\nimport {buffer, createEmpty, equals, getWidth} from '../../extent.js';\nimport {\n  create as createMat4,\n  fromTransform as mat4FromTransform,\n} from '../../vec/mat4.js';\nimport {\n  create as createTransform,\n  multiply as multiplyTransform,\n  setFromArray as setFromTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {listen, unlistenByKey} from '../../events.js';\nimport {packColor} from '../../webgl/styleparser.js';\n\nexport const Uniforms = {\n  ...DefaultUniform,\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  GLOBAL_ALPHA: 'u_globalAlpha',\n};\n\n/**\n * @typedef {function(import(\"../../Feature\").default):number|Array<number>} AttributeCallback A callback computing\n * the value of a custom attribute (different for each feature) to be passed on to the GPU.\n * Properties are available as 2nd arg for quicker access.\n */\n\n/**\n * @typedef {Object} CustomShaderProgram An object containing custom shaders (vertex and fragment); uses attributes and uniforms\n * provided to the renderer\n * @property {string} vertexShader Vertex shader source.\n * @property {string} fragmentShader Fragment shader source.\n */\n\n/**\n * @typedef {Object} DefaultShaderProgram An object containing attribute callbacks for the default shaders\n * @property {AttributeCallback} [color] Color value, encoded in a [number, number] array (use the {@link module:ol/webgl/styleparser~packColor} function)\n * @property {AttributeCallback} [width] Stroke width value\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {CustomShaderProgram|DefaultShaderProgram} [fill] Shaders for filling polygons.\n * @property {CustomShaderProgram|DefaultShaderProgram} [stroke] Shaders for line strings and polygon strokes.\n * @property {CustomShaderProgram|DefaultShaderProgram} [point] Shaders for points.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions.\n * @property {Array<import(\"../../render/webgl/BatchRenderer.js\").CustomAttribute>} [attributes] Attribute definitions.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Experimental WebGL vector renderer. Supports polygons, lines and points:\n *  * Polygons are broken down into triangles\n *  * Lines are rendered as strips of quads\n *  * Points are rendered as quads\n *\n * You need to provide vertex and fragment shaders as well as custom attributes for each type of geometry. All shaders\n * can access the uniforms in the {@link module:ol/webgl/Helper~DefaultUniform} enum.\n * The vertex shaders can access the following attributes depending on the geometry type:\n *  * For polygons: {@link module:ol/render/webgl/PolygonBatchRenderer~Attributes}\n *  * For line strings: {@link module:ol/render/webgl/LineStringBatchRenderer~Attributes}\n *  * For points: {@link module:ol/render/webgl/PointBatchRenderer~Attributes}\n *\n * Please note that the fragment shaders output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Note: this uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n */\nclass WebGLVectorLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    uniforms[Uniforms.RENDER_EXTENT] = [0, 0, 0, 0];\n    uniforms[Uniforms.GLOBAL_ALPHA] = 1;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.sourceRevision_ = -1;\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = createTransform();\n\n    this.tmpTransform_ = createTransform();\n    this.tmpMat4_ = createMat4();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentFrameStateTransform_ = createTransform();\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    /**\n     * @type {PolygonBatchRenderer}\n     * @private\n     */\n    this.polygonRenderer_ = null;\n    /**\n     * @type {PointBatchRenderer}\n     * @private\n     */\n    this.pointRenderer_ = null;\n\n    /**\n     * @type {LineStringBatchRenderer}\n     * @private\n     */\n    this.lineStringRenderer_ = null;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.fillVertexShader_;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.fillFragmentShader_;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.strokeVertexShader_;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.strokeFragmentShader_;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.pointVertexShader_;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.pointFragmentShader_;\n\n    /**\n     * @type {Array<import('../../render/webgl/BatchRenderer.js').CustomAttribute>}\n     * @private\n     */\n    this.fillAttributes_;\n\n    /**\n     * @type {Array<import('../../render/webgl/BatchRenderer.js').CustomAttribute>}\n     * @private\n     */\n    this.strokeAttributes_;\n\n    /**\n     * @type {Array<import('../../render/webgl/BatchRenderer.js').CustomAttribute>}\n     * @private\n     */\n    this.pointAttributes_;\n\n    this.applyOptions_(options);\n\n    /**\n     * @private\n     */\n    this.batch_ = new MixedGeometryBatch();\n\n    const source = this.getLayer().getSource();\n    this.batch_.addFeatures(source.getFeatures());\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this\n      ),\n    ];\n  }\n\n  /**\n   * @param {Options} options Options.\n   * @private\n   */\n  applyOptions_(options) {\n    this.fillAttributes_ = [];\n    this.strokeAttributes_ = [];\n    this.pointAttributes_ = [];\n\n    if (options.fill && 'vertexShader' in options.fill) {\n      this.fillVertexShader_ = options.fill.vertexShader;\n      this.fillFragmentShader_ = options.fill.fragmentShader;\n    } else {\n      this.fillVertexShader_ = FILL_VERTEX_SHADER;\n      this.fillFragmentShader_ = FILL_FRAGMENT_SHADER;\n      const colorCallback =\n        options.fill && 'color' in options.fill\n          ? options.fill.color\n          : () => packColor('#ddd');\n      this.fillAttributes_.push({\n        name: 'color',\n        size: 2,\n        callback: colorCallback,\n      });\n    }\n\n    if (options.stroke && 'vertexShader' in options.stroke) {\n      this.strokeVertexShader_ = options.stroke.vertexShader;\n      this.strokeFragmentShader_ = options.stroke.fragmentShader;\n    } else {\n      this.strokeVertexShader_ = STROKE_VERTEX_SHADER;\n      this.strokeFragmentShader_ = STROKE_FRAGMENT_SHADER;\n      const colorCallback =\n        options.stroke && 'color' in options.stroke\n          ? options.stroke.color\n          : () => packColor('#eee');\n      const widthCallback =\n        options.stroke && 'width' in options.stroke\n          ? options.stroke.width\n          : () => 1.5;\n      this.strokeAttributes_.push(\n        {\n          name: 'color',\n          size: 2,\n          callback: colorCallback,\n        },\n        {\n          name: 'width',\n          callback: widthCallback,\n        }\n      );\n    }\n\n    if (options.point && 'vertexShader' in options.point) {\n      this.pointVertexShader_ = options.point.vertexShader;\n      this.pointFragmentShader_ = options.point.fragmentShader;\n    } else {\n      this.pointVertexShader_ = POINT_VERTEX_SHADER;\n      this.pointFragmentShader_ = POINT_FRAGMENT_SHADER;\n      const colorCallback =\n        options.point && 'color' in options.point\n          ? options.point.color\n          : () => packColor('#eee');\n      this.pointAttributes_.push({\n        name: 'color',\n        size: 2,\n        callback: colorCallback,\n      });\n    }\n\n    if (options.attributes) {\n      this.fillAttributes_ = this.fillAttributes_.concat(options.attributes);\n      this.strokeAttributes_ = this.strokeAttributes_.concat(\n        options.attributes\n      );\n      this.pointAttributes_ = this.pointAttributes_.concat(options.attributes);\n    }\n  }\n\n  /**\n   * @private\n   */\n  createRenderers_() {\n    this.polygonRenderer_ = new PolygonBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.fillVertexShader_,\n      this.fillFragmentShader_,\n      this.fillAttributes_\n    );\n    this.pointRenderer_ = new PointBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.pointVertexShader_,\n      this.pointFragmentShader_,\n      this.pointAttributes_\n    );\n    this.lineStringRenderer_ = new LineStringBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.strokeVertexShader_,\n      this.strokeFragmentShader_,\n      this.strokeAttributes_\n    );\n  }\n\n  reset(options) {\n    this.applyOptions_(options);\n    if (this.helper) {\n      this.createRenderers_();\n    }\n    super.reset(options);\n  }\n\n  afterHelperCreated() {\n    this.createRenderers_();\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.batch_.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.batch_.changeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    this.batch_.removeFeature(feature);\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.batch_.clear();\n  }\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} batchInvertTransform Inverse of the transformation in which geometries are expressed\n   * @private\n   */\n  applyUniforms_(batchInvertTransform) {\n    // world to screen matrix\n    setFromTransform(this.tmpTransform_, this.currentFrameStateTransform_);\n    multiplyTransform(this.tmpTransform_, batchInvertTransform);\n    this.helper.setUniformMatrixValue(\n      Uniforms.PROJECTION_MATRIX,\n      mat4FromTransform(this.tmpMat4_, this.tmpTransform_)\n    );\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    this.helper.prepareDraw(frameState);\n    this.currentFrameStateTransform_ = this.helper.makeProjectionTransform(\n      frameState,\n      this.currentFrameStateTransform_\n    );\n\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const projection = frameState.viewState.projection;\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const projectionExtent = projection.getExtent();\n    const extent = frameState.extent;\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n    let world = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n\n    translateTransform(this.tmpTransform_, world * worldWidth, 0);\n    do {\n      this.polygonRenderer_.preRender(this.batch_.polygonBatch, frameState);\n      this.applyUniforms_(\n        this.batch_.polygonBatch.invertVerticesBufferTransform\n      );\n      this.polygonRenderer_.render(this.batch_.polygonBatch);\n\n      this.lineStringRenderer_.preRender(\n        this.batch_.lineStringBatch,\n        frameState\n      );\n      this.applyUniforms_(\n        this.batch_.lineStringBatch.invertVerticesBufferTransform\n      );\n      this.lineStringRenderer_.render(this.batch_.lineStringBatch);\n\n      this.pointRenderer_.preRender(this.batch_.pointBatch, frameState);\n      this.applyUniforms_(this.batch_.pointBatch.invertVerticesBufferTransform);\n      this.pointRenderer_.render(this.batch_.pointBatch);\n\n      translateTransform(this.currentFrameStateTransform_, worldWidth, 0);\n    } while (++world < endWorld);\n\n    this.helper.finalizeDraw(frameState);\n\n    const canvas = this.helper.getCanvas();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const opacity = layerState.opacity;\n    if (opacity !== parseFloat(canvas.style.opacity)) {\n      canvas.style.opacity = String(opacity);\n    }\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.ready = false;\n      let remaining = 3;\n      const rebuildCb = () => {\n        remaining--;\n        this.ready = remaining <= 0;\n        this.getLayer().changed();\n      };\n\n      const transform = this.helper.makeProjectionTransform(\n        frameState,\n        createTransform()\n      );\n\n      this.polygonRenderer_.rebuild(\n        this.batch_.polygonBatch,\n        transform,\n        'Polygon',\n        rebuildCb\n      );\n      this.lineStringRenderer_.rebuild(\n        this.batch_.lineStringBatch,\n        transform,\n        'LineString',\n        rebuildCb\n      );\n      this.pointRenderer_.rebuild(\n        this.batch_.pointBatch,\n        transform,\n        'Point',\n        rebuildCb\n      );\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLVectorLayerRenderer;\n","import GeoJSON from '../src/ol/format/GeoJSON.js';\nimport Layer from '../src/ol/layer/Layer.js';\nimport Map from '../src/ol/Map.js';\nimport OSM from '../src/ol/source/OSM.js';\nimport TileLayer from '../src/ol/layer/WebGLTile.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport View from '../src/ol/View.js';\nimport WebGLVectorLayerRenderer from '../src/ol/renderer/webgl/VectorLayer.js';\nimport {parseLiteralStyle} from '../src/ol/webgl/styleparser.js';\n\n/** @type {import('../src/ol/style/literal.js').LiteralStyle} */\nconst style = {\n  'stroke-color': ['*', ['get', 'COLOR'], [220, 220, 220]],\n  'stroke-width': 1.5,\n  'fill-color': ['*', ['get', 'COLOR'], [255, 255, 255, 0.6]],\n};\n\nclass WebGLLayer extends Layer {\n  createRenderer() {\n    const parseResult = parseLiteralStyle(style);\n    return new WebGLVectorLayerRenderer(this, {\n      fill: {\n        vertexShader: parseResult.builder.getFillVertexShader(),\n        fragmentShader: parseResult.builder.getFillFragmentShader(),\n      },\n      stroke: {\n        vertexShader: parseResult.builder.getStrokeVertexShader(),\n        fragmentShader: parseResult.builder.getStrokeFragmentShader(),\n      },\n      attributes: parseResult.attributes,\n      uniforms: parseResult.uniforms,\n    });\n  }\n}\n\nconst osm = new TileLayer({\n  source: new OSM(),\n});\n\nconst vectorLayer = new WebGLLayer({\n  source: new VectorSource({\n    url: 'https://openlayers.org/data/vector/ecoregions.json',\n    format: new GeoJSON(),\n  }),\n});\n\nconst map = new Map({\n  layers: [osm, vectorLayer],\n  target: 'map',\n  view: new View({\n    center: [0, 0],\n    zoom: 1,\n  }),\n});\n"],"names":["Uniforms","RENDER_EXTENT","GLOBAL_ALPHA","WebGLVectorLayerRenderer","constructor","layer","options","uniforms","super","postProcesses","this","sourceRevision_","previousExtent_","currentTransform_","tmpTransform_","tmpMat4_","currentFrameStateTransform_","worker_","polygonRenderer_","pointRenderer_","lineStringRenderer_","fillVertexShader_","fillFragmentShader_","strokeVertexShader_","strokeFragmentShader_","pointVertexShader_","pointFragmentShader_","fillAttributes_","strokeAttributes_","pointAttributes_","applyOptions_","batch_","MixedGeometryBatch","source","getLayer","getSource","addFeatures","getFeatures","sourceListenKeys_","VectorEventType","handleSourceFeatureAdded_","handleSourceFeatureChanged_","handleSourceFeatureDelete_","handleSourceFeatureClear_","fill","vertexShader","fragmentShader","colorCallback","color","push","name","size","callback","stroke","widthCallback","width","point","attributes","concat","createRenderers_","PolygonBatchRenderer","helper","PointBatchRenderer","LineStringBatchRenderer","reset","afterHelperCreated","event","feature","addFeature","changeFeature","removeFeature","clear","applyUniforms_","batchInvertTransform","setUniformMatrixValue","PROJECTION_MATRIX","mat4","renderFrame","frameState","gl","getGL","preRender","prepareDraw","makeProjectionTransform","vectorSource","projection","viewState","multiWorld","getWrapX","canWrapX","projectionExtent","getExtent","extent","worldWidth","endWorld","Math","ceil","world","floor","polygonBatch","invertVerticesBufferTransform","render","lineStringBatch","pointBatch","finalizeDraw","canvas","getCanvas","opacity","layerStatesArray","layerIndex","parseFloat","style","String","postRender","prepareFrameInternal","viewNotMoving","viewHints","ViewHint","extentChanged","sourceChanged","getRevision","resolution","renderBuffer","BaseVector","getRenderBuffer","loadFeatures","ready","remaining","rebuildCb","changed","transform","rebuild","slice","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","disposeInternal","terminate","layer_","forEach","key","WebGLLayer","Layer","createRenderer","parseResult","builder","getFillVertexShader","getFillFragmentShader","getStrokeVertexShader","getStrokeFragmentShader","osm","OSM","vectorLayer","Vector","url","format","GeoJSON","Map","layers","target","view","View","center","zoom"],"sourceRoot":""}