{"version":3,"file":"webgl-vector-layer.js","mappings":"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","sources":["webpack:///../src/ol/renderer/webgl/VectorLayer.js","webpack:///./webgl-vector-layer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/VectorLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport LineStringBatchRenderer from '../../render/webgl/LineStringBatchRenderer.js';\nimport MixedGeometryBatch from '../../render/webgl/MixedGeometryBatch.js';\nimport PointBatchRenderer from '../../render/webgl/PointBatchRenderer.js';\nimport PolygonBatchRenderer from '../../render/webgl/PolygonBatchRenderer.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {DefaultUniform} from '../../webgl/Helper.js';\nimport {\n  FILL_FRAGMENT_SHADER,\n  FILL_VERTEX_SHADER,\n  POINT_FRAGMENT_SHADER,\n  POINT_VERTEX_SHADER,\n  STROKE_FRAGMENT_SHADER,\n  STROKE_VERTEX_SHADER,\n  packColor,\n} from './shaders.js';\nimport {buffer, createEmpty, equals, getWidth} from '../../extent.js';\nimport {\n  create as createTransform,\n  multiply as multiplyTransform,\n  setFromArray as setFromTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {listen, unlistenByKey} from '../../events.js';\n\nexport const Uniforms = {\n  ...DefaultUniform,\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  GLOBAL_ALPHA: 'u_globalAlpha',\n};\n\n/**\n * @typedef {function(import(\"../../Feature\").default, Object<string, *>):number} CustomAttributeCallback A callback computing\n * the value of a custom attribute (different for each feature) to be passed on to the GPU.\n * Properties are available as 2nd arg for quicker access.\n */\n\n/**\n * @typedef {Object} ShaderProgram An object containing both shaders (vertex and fragment) as well as the required attributes\n * @property {string} [vertexShader] Vertex shader source (using the default one if unspecified).\n * @property {string} [fragmentShader] Fragment shader source (using the default one if unspecified).\n * @property {Object<import(\"./shaders.js\").DefaultAttributes,CustomAttributeCallback>} attributes Custom attributes made available in the vertex shader.\n * Keys are the names of the attributes which are then accessible in the vertex shader using the `a_` prefix, e.g.: `a_opacity`.\n * Default shaders rely on the attributes in {@link module:ol/render/webgl/shaders~DefaultAttributes}.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {ShaderProgram} [fill] Attributes and shaders for filling polygons.\n * @property {ShaderProgram} [stroke] Attributes and shaders for line strings and polygon strokes.\n * @property {ShaderProgram} [point] Attributes and shaders for points.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @param {Object<import(\"./shaders.js\").DefaultAttributes,CustomAttributeCallback>} obj Lookup of attribute getters.\n * @return {Array<import(\"../../render/webgl/BatchRenderer\").CustomAttribute>} An array of attribute descriptors.\n */\nfunction toAttributesArray(obj) {\n  return Object.keys(obj).map((key) => ({name: key, callback: obj[key]}));\n}\n\n/**\n * @classdesc\n * Experimental WebGL vector renderer. Supports polygons, lines and points:\n *  * Polygons are broken down into triangles\n *  * Lines are rendered as strips of quads\n *  * Points are rendered as quads\n *\n * You need to provide vertex and fragment shaders as well as custom attributes for each type of geometry. All shaders\n * can access the uniforms in the {@link module:ol/webgl/Helper~DefaultUniform} enum.\n * The vertex shaders can access the following attributes depending on the geometry type:\n *  * For polygons: {@link module:ol/render/webgl/PolygonBatchRenderer~Attributes}\n *  * For line strings: {@link module:ol/render/webgl/LineStringBatchRenderer~Attributes}\n *  * For points: {@link module:ol/render/webgl/PointBatchRenderer~Attributes}\n *\n * Please note that the fragment shaders output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Note: this uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n */\nclass WebGLVectorLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[Uniforms.PROJECTION_MATRIX] = projectionMatrixTransform;\n    uniforms[Uniforms.RENDER_EXTENT] = [0, 0, 0, 0];\n    uniforms[Uniforms.GLOBAL_ALPHA] = 1;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.sourceRevision_ = -1;\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentFrameStateTransform_ = createTransform();\n\n    const fillAttributes = {\n      color: function () {\n        return packColor('#ddd');\n      },\n      opacity: function () {\n        return 1;\n      },\n      ...(options.fill && options.fill.attributes),\n    };\n\n    const strokeAttributes = {\n      color: function () {\n        return packColor('#eee');\n      },\n      opacity: function () {\n        return 1;\n      },\n      width: function () {\n        return 1.5;\n      },\n      ...(options.stroke && options.stroke.attributes),\n    };\n\n    const pointAttributes = {\n      color: function () {\n        return packColor('#eee');\n      },\n      opacity: function () {\n        return 1;\n      },\n      ...(options.point && options.point.attributes),\n    };\n\n    this.fillVertexShader_ =\n      (options.fill && options.fill.vertexShader) || FILL_VERTEX_SHADER;\n    this.fillFragmentShader_ =\n      (options.fill && options.fill.fragmentShader) || FILL_FRAGMENT_SHADER;\n    this.fillAttributes_ = toAttributesArray(fillAttributes);\n\n    this.strokeVertexShader_ =\n      (options.stroke && options.stroke.vertexShader) || STROKE_VERTEX_SHADER;\n    this.strokeFragmentShader_ =\n      (options.stroke && options.stroke.fragmentShader) ||\n      STROKE_FRAGMENT_SHADER;\n    this.strokeAttributes_ = toAttributesArray(strokeAttributes);\n\n    this.pointVertexShader_ =\n      (options.point && options.point.vertexShader) || POINT_VERTEX_SHADER;\n    this.pointFragmentShader_ =\n      (options.point && options.point.fragmentShader) || POINT_FRAGMENT_SHADER;\n    this.pointAttributes_ = toAttributesArray(pointAttributes);\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    /**\n     * @private\n     */\n    this.batch_ = new MixedGeometryBatch();\n\n    const source = this.getLayer().getSource();\n    this.batch_.addFeatures(source.getFeatures());\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this\n      ),\n    ];\n  }\n\n  afterHelperCreated() {\n    this.polygonRenderer_ = new PolygonBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.fillVertexShader_,\n      this.fillFragmentShader_,\n      this.fillAttributes_\n    );\n    this.pointRenderer_ = new PointBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.pointVertexShader_,\n      this.pointFragmentShader_,\n      this.pointAttributes_\n    );\n    this.lineStringRenderer_ = new LineStringBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.strokeVertexShader_,\n      this.strokeFragmentShader_,\n      this.strokeAttributes_\n    );\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.batch_.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.batch_.changeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    this.batch_.removeFeature(feature);\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.batch_.clear();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const projection = frameState.viewState.projection;\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const projectionExtent = projection.getExtent();\n    const extent = frameState.extent;\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n    let world = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n\n    const baseTransform = this.helper.makeProjectionTransform(\n      frameState,\n      this.currentFrameStateTransform_\n    );\n    translateTransform(baseTransform, world * worldWidth, 0);\n\n    do {\n      setFromTransform(this.currentTransform_, baseTransform);\n      multiplyTransform(\n        this.currentTransform_,\n        this.batch_.polygonBatch.invertVerticesBufferTransform\n      );\n      this.polygonRenderer_.preRender(this.batch_.polygonBatch, frameState);\n      this.polygonRenderer_.render(this.batch_.polygonBatch);\n      setFromTransform(this.currentTransform_, baseTransform);\n      multiplyTransform(\n        this.currentTransform_,\n        this.batch_.lineStringBatch.invertVerticesBufferTransform\n      );\n      this.lineStringRenderer_.preRender(\n        this.batch_.lineStringBatch,\n        frameState\n      );\n      this.lineStringRenderer_.render(this.batch_.lineStringBatch);\n      setFromTransform(this.currentTransform_, baseTransform);\n      multiplyTransform(\n        this.currentTransform_,\n        this.batch_.lineStringBatch.invertVerticesBufferTransform\n      );\n      this.pointRenderer_.preRender(this.batch_.pointBatch, frameState);\n      this.pointRenderer_.render(this.batch_.pointBatch);\n\n      translateTransform(baseTransform, worldWidth, 0);\n    } while (++world < endWorld);\n\n    this.helper.finalizeDraw(frameState);\n\n    const canvas = this.helper.getCanvas();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const opacity = layerState.opacity;\n    if (opacity !== parseFloat(canvas.style.opacity)) {\n      canvas.style.opacity = String(opacity);\n    }\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.ready = false;\n      let remaining = 3;\n      const rebuildCb = () => {\n        remaining--;\n        this.ready = remaining <= 0;\n        this.getLayer().changed();\n      };\n\n      const transform = this.helper.makeProjectionTransform(\n        frameState,\n        createTransform()\n      );\n\n      this.polygonRenderer_.rebuild(\n        this.batch_.polygonBatch,\n        transform,\n        'Polygon',\n        rebuildCb\n      );\n      this.lineStringRenderer_.rebuild(\n        this.batch_.lineStringBatch,\n        transform,\n        'LineString',\n        rebuildCb\n      );\n      this.pointRenderer_.rebuild(\n        this.batch_.pointBatch,\n        transform,\n        'Point',\n        rebuildCb\n      );\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.prepareDraw(frameState);\n\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLVectorLayerRenderer;\n","import GeoJSON from '../src/ol/format/GeoJSON.js';\nimport Layer from '../src/ol/layer/Layer.js';\nimport Map from '../src/ol/Map.js';\nimport OSM from '../src/ol/source/OSM.js';\nimport TileLayer from '../src/ol/layer/WebGLTile.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport View from '../src/ol/View.js';\nimport WebGLVectorLayerRenderer from '../src/ol/renderer/webgl/VectorLayer.js';\nimport {asArray} from '../src/ol/color.js';\nimport {packColor} from '../src/ol/renderer/webgl/shaders.js';\n\nclass WebGLLayer extends Layer {\n  createRenderer() {\n    return new WebGLVectorLayerRenderer(this, {\n      fill: {\n        attributes: {\n          color: function (feature) {\n            const color = asArray(feature.get('COLOR') || '#eee');\n            color[3] = 0.85;\n            return packColor(color);\n          },\n          opacity: function () {\n            return 0.6;\n          },\n        },\n      },\n      stroke: {\n        attributes: {\n          color: function (feature) {\n            const color = [...asArray(feature.get('COLOR') || '#eee')];\n            color.forEach((_, i) => (color[i] = Math.round(color[i] * 0.75))); // darken slightly\n            return packColor(color);\n          },\n          width: function () {\n            return 1.5;\n          },\n          opacity: function () {\n            return 1;\n          },\n        },\n      },\n    });\n  }\n}\n\nconst osm = new TileLayer({\n  source: new OSM(),\n});\n\nconst vectorLayer = new WebGLLayer({\n  source: new VectorSource({\n    url: 'https://openlayers.org/data/vector/ecoregions.json',\n    format: new GeoJSON(),\n  }),\n});\n\nconst map = new Map({\n  layers: [osm, vectorLayer],\n  target: 'map',\n  view: new View({\n    center: [0, 0],\n    zoom: 1,\n  }),\n});\n"],"names":["Uniforms","RENDER_EXTENT","GLOBAL_ALPHA","toAttributesArray","obj","Object","keys","map","key","name","callback","WebGLVectorLayerRenderer","constructor","layer","options","uniforms","projectionMatrixTransform","PROJECTION_MATRIX","super","postProcesses","this","sourceRevision_","previousExtent_","currentTransform_","currentFrameStateTransform_","fillAttributes","color","opacity","fill","attributes","strokeAttributes","width","stroke","pointAttributes","point","fillVertexShader_","vertexShader","fillFragmentShader_","fragmentShader","fillAttributes_","strokeVertexShader_","strokeFragmentShader_","strokeAttributes_","pointVertexShader_","pointFragmentShader_","pointAttributes_","worker_","batch_","MixedGeometryBatch","source","getLayer","getSource","addFeatures","getFeatures","sourceListenKeys_","VectorEventType","handleSourceFeatureAdded_","handleSourceFeatureChanged_","handleSourceFeatureDelete_","handleSourceFeatureClear_","afterHelperCreated","polygonRenderer_","PolygonBatchRenderer","helper","pointRenderer_","PointBatchRenderer","lineStringRenderer_","LineStringBatchRenderer","event","feature","addFeature","changeFeature","removeFeature","clear","renderFrame","frameState","gl","getGL","preRender","vectorSource","projection","viewState","multiWorld","getWrapX","canWrapX","projectionExtent","getExtent","extent","worldWidth","endWorld","Math","ceil","world","floor","baseTransform","makeProjectionTransform","polygonBatch","invertVerticesBufferTransform","render","lineStringBatch","pointBatch","finalizeDraw","canvas","getCanvas","layerStatesArray","layerIndex","parseFloat","style","String","postRender","prepareFrameInternal","viewNotMoving","viewHints","ViewHint","extentChanged","sourceChanged","getRevision","resolution","renderBuffer","BaseVector","getRenderBuffer","loadFeatures","ready","remaining","rebuildCb","changed","transform","rebuild","slice","prepareDraw","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","disposeInternal","terminate","layer_","forEach","WebGLLayer","Layer","createRenderer","get","_","i","round","osm","OSM","vectorLayer","Vector","url","format","GeoJSON","Map","layers","target","view","View","center","zoom"],"sourceRoot":""}