{"version":3,"file":"tracing.js","mappings":"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","sources":["webpack:///./tracing.js"],"sourcesContent":["import Draw from '../src/ol/interaction/Draw.js';\nimport Feature from '../src/ol/Feature.js';\nimport Fill from '../src/ol/style/Fill.js';\nimport GeoJSON from '../src/ol/format/GeoJSON.js';\nimport LineString from '../src/ol/geom/LineString.js';\nimport Map from '../src/ol/Map.js';\nimport Snap from '../src/ol/interaction/Snap.js';\nimport Stroke from '../src/ol/style/Stroke.js';\nimport Style from '../src/ol/style/Style.js';\nimport View from '../src/ol/View.js';\nimport {OSM, Vector as VectorSource} from '../src/ol/source.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\n\n// math utilities\n\n// coordinates; will return the length of the [a, b] segment\nfunction length(a, b) {\n  return Math.sqrt(\n    (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])\n  );\n}\n\n// coordinates; will return true if c is on the [a, b] segment\nfunction isOnSegment(c, a, b) {\n  const lengthAc = length(a, c);\n  const lengthAb = length(a, b);\n  const dot =\n    ((c[0] - a[0]) * (b[0] - a[0]) + (c[1] - a[1]) * (b[1] - a[1])) / lengthAb;\n  return Math.abs(lengthAc - dot) < 1e-6 && lengthAc < lengthAb;\n}\n\n// modulo for negative values, eg: mod(-1, 4) returns 3\nfunction mod(a, b) {\n  return ((a % b) + b) % b;\n}\n\n// returns a coordinates array which contains the segments of the feature's\n// outer ring between the start and end points\n// Note: this assumes the base feature is a single polygon\nfunction getPartialRingCoords(feature, startPoint, endPoint) {\n  let polygon = feature.getGeometry();\n  if (polygon.getType() === 'MultiPolygon') {\n    polygon = polygon.getPolygon(0);\n  }\n  const ringCoords = polygon.getLinearRing().getCoordinates();\n\n  let i,\n    pointA,\n    pointB,\n    startSegmentIndex = -1;\n  for (i = 0; i < ringCoords.length; i++) {\n    pointA = ringCoords[i];\n    pointB = ringCoords[mod(i + 1, ringCoords.length)];\n\n    // check if this is the start segment dot product\n    if (isOnSegment(startPoint, pointA, pointB)) {\n      startSegmentIndex = i;\n      break;\n    }\n  }\n\n  const cwCoordinates = [];\n  let cwLength = 0;\n  const ccwCoordinates = [];\n  let ccwLength = 0;\n\n  // build clockwise coordinates\n  for (i = 0; i < ringCoords.length; i++) {\n    pointA =\n      i === 0\n        ? startPoint\n        : ringCoords[mod(i + startSegmentIndex, ringCoords.length)];\n    pointB = ringCoords[mod(i + startSegmentIndex + 1, ringCoords.length)];\n    cwCoordinates.push(pointA);\n\n    if (isOnSegment(endPoint, pointA, pointB)) {\n      cwCoordinates.push(endPoint);\n      cwLength += length(pointA, endPoint);\n      break;\n    } else {\n      cwLength += length(pointA, pointB);\n    }\n  }\n\n  // build counter-clockwise coordinates\n  for (i = 0; i < ringCoords.length; i++) {\n    pointA = ringCoords[mod(startSegmentIndex - i, ringCoords.length)];\n    pointB =\n      i === 0\n        ? startPoint\n        : ringCoords[mod(startSegmentIndex - i + 1, ringCoords.length)];\n    ccwCoordinates.push(pointB);\n\n    if (isOnSegment(endPoint, pointA, pointB)) {\n      ccwCoordinates.push(endPoint);\n      ccwLength += length(endPoint, pointB);\n      break;\n    } else {\n      ccwLength += length(pointA, pointB);\n    }\n  }\n\n  // keep the shortest path\n  return ccwLength < cwLength ? ccwCoordinates : cwCoordinates;\n}\n\n// layers definition\n\nconst raster = new TileLayer({\n  source: new OSM(),\n});\n\n// features in this layer will be snapped to\nconst baseVector = new VectorLayer({\n  source: new VectorSource({\n    format: new GeoJSON(),\n    url: \"https://ahocevar.com/geoserver/wfs?service=wfs&request=getfeature&typename=topp:states&cql_filter=STATE_NAME='Idaho'&outputformat=application/json\",\n  }),\n});\n\n// this is were the drawn features go\nconst drawVector = new VectorLayer({\n  source: new VectorSource(),\n  style: new Style({\n    stroke: new Stroke({\n      color: 'rgba(100, 255, 0, 1)',\n      width: 2,\n    }),\n    fill: new Fill({\n      color: 'rgba(100, 255, 0, 0.3)',\n    }),\n  }),\n});\n\n// this line only appears when we're tracing a feature outer ring\nconst previewLine = new Feature({\n  geometry: new LineString([]),\n});\nconst previewVector = new VectorLayer({\n  source: new VectorSource({\n    features: [previewLine],\n  }),\n  style: new Style({\n    stroke: new Stroke({\n      color: 'rgba(255, 0, 0, 1)',\n      width: 2,\n    }),\n  }),\n});\n\nconst map = new Map({\n  layers: [raster, baseVector, drawVector, previewVector],\n  target: 'map',\n  view: new View({\n    center: [-12986427, 5678422],\n    zoom: 5,\n  }),\n});\n\nlet drawInteraction, tracingFeature, startPoint, endPoint;\nlet drawing = false;\n\nconst getFeatureOptions = {\n  hitTolerance: 10,\n  layerFilter: (layer) => {\n    return layer === baseVector;\n  },\n};\n\n// the click event is used to start/end tracing around a feature\nmap.on('click', (event) => {\n  if (!drawing) {\n    return;\n  }\n\n  let hit = false;\n  map.forEachFeatureAtPixel(\n    event.pixel,\n    (feature) => {\n      if (tracingFeature && feature !== tracingFeature) {\n        return;\n      }\n\n      hit = true;\n      const coord = map.getCoordinateFromPixel(event.pixel);\n\n      // second click on the tracing feature: append the ring coordinates\n      if (feature === tracingFeature) {\n        endPoint = tracingFeature.getGeometry().getClosestPoint(coord);\n        const appendCoords = getPartialRingCoords(\n          tracingFeature,\n          startPoint,\n          endPoint\n        );\n        drawInteraction.removeLastPoint();\n        drawInteraction.appendCoordinates(appendCoords);\n        tracingFeature = null;\n      }\n\n      // start tracing on the feature ring\n      tracingFeature = feature;\n      startPoint = tracingFeature.getGeometry().getClosestPoint(coord);\n    },\n    getFeatureOptions\n  );\n\n  if (!hit) {\n    // clear current tracing feature & preview\n    previewLine.getGeometry().setCoordinates([]);\n    tracingFeature = null;\n  }\n});\n\n// the pointermove event is used to show a preview of the result of the tracing\nmap.on('pointermove', (event) => {\n  if (tracingFeature && drawing) {\n    let coord = null;\n    map.forEachFeatureAtPixel(\n      event.pixel,\n      (feature) => {\n        if (tracingFeature === feature) {\n          coord = map.getCoordinateFromPixel(event.pixel);\n        }\n      },\n      getFeatureOptions\n    );\n\n    let previewCoords = [];\n    if (coord) {\n      endPoint = tracingFeature.getGeometry().getClosestPoint(coord);\n      previewCoords = getPartialRingCoords(\n        tracingFeature,\n        startPoint,\n        endPoint\n      );\n    }\n    previewLine.getGeometry().setCoordinates(previewCoords);\n  }\n});\n\nconst snapInteraction = new Snap({\n  source: baseVector.getSource(),\n});\n\nconst typeSelect = document.getElementById('type');\n\nfunction addInteraction() {\n  const value = typeSelect.value;\n  if (value !== 'None') {\n    drawInteraction = new Draw({\n      source: drawVector.getSource(),\n      type: value,\n    });\n    drawInteraction.on('drawstart', () => {\n      drawing = true;\n    });\n    drawInteraction.on('drawend', () => {\n      drawing = false;\n      previewLine.getGeometry().setCoordinates([]);\n      tracingFeature = null;\n    });\n    map.addInteraction(drawInteraction);\n    map.addInteraction(snapInteraction);\n  }\n}\n\ntypeSelect.onchange = function () {\n  map.removeInteraction(drawInteraction);\n  map.removeInteraction(snapInteraction);\n  addInteraction();\n};\naddInteraction();\n"],"names":["length","a","b","Math","sqrt","isOnSegment","c","lengthAc","lengthAb","dot","abs","mod","getPartialRingCoords","feature","startPoint","endPoint","polygon","getGeometry","getType","getPolygon","ringCoords","getLinearRing","getCoordinates","i","pointA","pointB","startSegmentIndex","cwCoordinates","cwLength","ccwCoordinates","ccwLength","push","raster","source","baseVector","format","url","drawVector","style","stroke","color","width","fill","previewLine","geometry","previewVector","features","map","layers","target","view","center","zoom","drawInteraction","tracingFeature","drawing","getFeatureOptions","hitTolerance","layerFilter","layer","on","event","hit","forEachFeatureAtPixel","pixel","coord","getCoordinateFromPixel","getClosestPoint","appendCoords","removeLastPoint","appendCoordinates","setCoordinates","previewCoords","snapInteraction","getSource","typeSelect","document","getElementById","addInteraction","value","type","onchange","removeInteraction"],"sourceRoot":""}