{"version":3,"file":"webgl-vector-tiles.js","mappings":"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","sources":["webpack:///../src/ol/webgl/TileGeometry.js","webpack:///../src/ol/renderer/webgl/VectorTileLayer.js","webpack:///./webgl-vector-tiles.js"],"sourcesContent":["/**\n * @module ol/webgl/TileGeometry\n */\n\nimport BaseTileRepresentation from './BaseTileRepresentation.js';\nimport MixedGeometryBatch from '../render/webgl/MixedGeometryBatch.js';\nimport {\n  create as createTransform,\n  translate as translateTransform,\n} from '../transform.js';\n\n/**\n * @typedef {import(\"../VectorRenderTile\").default} TileType\n */\n\n/**\n * @extends {BaseTileRepresentation<TileType>}\n */\nclass TileGeometry extends BaseTileRepresentation {\n  /**\n   * @param {import(\"./BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options The tile texture options.\n   * @param {Array<import(\"../render/webgl/VectorStyleRenderer.js\").default>} styleRenderers Array of vector style renderers\n   */\n  constructor(options, styleRenderers) {\n    super(options);\n\n    /**\n     * @private\n     */\n    this.batch_ = new MixedGeometryBatch();\n\n    /**\n     * @private\n     */\n    this.styleRenderers_ = styleRenderers;\n\n    /**\n     * @type {Array<import(\"../render/webgl/VectorStyleRenderer.js\").WebGLBuffers>}\n     */\n    this.buffers = [];\n\n    this.setTile(options.tile);\n  }\n\n  uploadTile() {\n    this.batch_.clear();\n    const sourceTiles = this.tile.getSourceTiles();\n    const features = sourceTiles.reduce(\n      (accumulator, sourceTile) => accumulator.concat(sourceTile.getFeatures()),\n      []\n    );\n    this.batch_.addFeatures(features);\n\n    const tileOriginX = sourceTiles[0].extent[0];\n    const tileOriginY = sourceTiles[0].extent[1];\n    const transform = translateTransform(\n      createTransform(),\n      -tileOriginX,\n      -tileOriginY\n    );\n\n    const generatePromises = this.styleRenderers_.map((renderer, i) =>\n      renderer.generateBuffers(this.batch_, transform).then((buffers) => {\n        this.buffers[i] = buffers;\n      })\n    );\n    Promise.all(generatePromises).then(() => {\n      this.setReady();\n    });\n  }\n}\n\nexport default TileGeometry;\n","/**\n * @module ol/renderer/webgl/VectorTileLayer\n */\nimport EventType from '../../events/EventType.js';\nimport TileGeometry from '../../webgl/TileGeometry.js';\nimport VectorStyleRenderer from '../../render/webgl/VectorStyleRenderer.js';\nimport WebGLBaseTileLayerRenderer, {Uniforms} from './TileLayerBase.js';\nimport {\n  create as createMat4,\n  fromTransform as mat4FromTransform,\n} from '../../vec/mat4.js';\nimport {\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  setFromArray as setFromTransform,\n} from '../../transform.js';\nimport {getIntersection} from '../../extent.js';\n\n/**\n * @typedef {import('../../render/webgl/VectorStyleRenderer.js').VectorStyle} VectorStyle\n */\n\n/**\n * @typedef {Object} Options\n * @property {VectorStyle|Array<VectorStyle>} style Vector style as literal style or shaders; can also accept an array of styles\n * @property {number} [cacheSize=512] The vector tile cache size.\n */\n\n/**\n * @typedef {import(\"../../layer/BaseTile.js\").default} LayerType\n */\n\n/**\n * @classdesc\n * WebGL renderer for vector tile layers. Experimental.\n * @extends {WebGLBaseTileLayerRenderer<LayerType>}\n */\nclass WebGLVectorTileLayerRenderer extends WebGLBaseTileLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, options);\n\n    /**\n     * @type {Array<VectorStyle>}\n     * @private\n     */\n    this.styles_ = [];\n\n    /**\n     * @type {Array<VectorStyleRenderer>}\n     * @private\n     */\n    this.styleRenderers_ = [];\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentFrameStateTransform_ = createTransform();\n\n    this.tmpTransform_ = createTransform();\n    this.tmpMat4_ = createMat4();\n\n    this.applyOptions_(options);\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset(options);\n\n    this.applyOptions_(options);\n    if (this.helper) {\n      this.createRenderers_();\n    }\n  }\n\n  /**\n   * @param {Options} options Options.\n   * @private\n   */\n  applyOptions_(options) {\n    this.styles_ = Array.isArray(options.style)\n      ? options.style\n      : [options.style];\n  }\n\n  /**\n   * @private\n   */\n  createRenderers_() {\n    this.styleRenderers_ = this.styles_.map(\n      (style) => new VectorStyleRenderer(style, this.helper)\n    );\n  }\n\n  afterHelperCreated() {\n    this.createRenderers_();\n  }\n\n  createTileRepresentation(options) {\n    const tileRep = new TileGeometry(options, this.styleRenderers_);\n    // redraw the layer when the tile is ready\n    const listener = () => {\n      if (tileRep.ready) {\n        this.getLayer().changed();\n        tileRep.removeEventListener(EventType.CHANGE, listener);\n      }\n    };\n    tileRep.addEventListener(EventType.CHANGE, listener);\n    return tileRep;\n  }\n\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    super.beforeTilesRender(frameState, true); // always consider that tiles need alpha blending\n    this.helper.makeProjectionTransform(\n      frameState,\n      this.currentFrameStateTransform_\n    );\n  }\n\n  /**\n   * @param {number} alpha Alpha value of the tile\n   * @param {import(\"../../extent.js\").Extent} renderExtent Which extent to restrict drawing to\n   * @param {import(\"../../transform.js\").Transform} batchInvertTransform Inverse of the transformation in which tile geometries are expressed\n   * @private\n   */\n  applyUniforms_(alpha, renderExtent, batchInvertTransform) {\n    // world to screen matrix\n    setFromTransform(this.tmpTransform_, this.currentFrameStateTransform_);\n    multiplyTransform(this.tmpTransform_, batchInvertTransform);\n    this.helper.setUniformMatrixValue(\n      Uniforms.PROJECTION_MATRIX,\n      mat4FromTransform(this.tmpMat4_, this.tmpTransform_)\n    );\n\n    // screen to world matrix\n    makeInverseTransform(this.tmpTransform_, this.currentFrameStateTransform_);\n    this.helper.setUniformMatrixValue(\n      Uniforms.SCREEN_TO_WORLD_MATRIX,\n      mat4FromTransform(this.tmpMat4_, this.tmpTransform_)\n    );\n\n    this.helper.setUniformFloatValue(Uniforms.GLOBAL_ALPHA, alpha);\n    this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, renderExtent);\n  }\n\n  renderTile(\n    tileRepresentation,\n    tileTransform,\n    frameState,\n    renderExtent,\n    tileResolution,\n    tileSize,\n    tileOrigin,\n    tileExtent,\n    depth,\n    gutter,\n    alpha\n  ) {\n    const gutterExtent = getIntersection(tileExtent, renderExtent, tileExtent);\n\n    for (let i = 0, ii = this.styleRenderers_.length; i < ii; i++) {\n      const renderer = this.styleRenderers_[i];\n      const buffers = tileRepresentation.buffers[i];\n      if (!buffers) {\n        continue;\n      }\n      renderer.render(buffers, frameState, () => {\n        this.applyUniforms_(\n          alpha,\n          gutterExtent,\n          buffers.invertVerticesTransform\n        );\n      });\n    }\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {}\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLVectorTileLayerRenderer;\n","import MVT from '../src/ol/format/MVT.js';\nimport Map from '../src/ol/Map.js';\nimport VectorTile from '../src/ol/layer/VectorTile.js';\nimport VectorTileSource from '../src/ol/source/VectorTile.js';\nimport View from '../src/ol/View.js';\nimport WebGLVectorTileLayerRenderer from '../src/ol/renderer/webgl/VectorTileLayer.js';\nimport {Fill, Icon, Stroke, Style, Text} from '../src/ol/style.js';\nimport {asArray} from '../src/ol/color.js';\nimport {packColor, parseLiteralStyle} from '../src/ol/webgl/styleparser.js';\n\nconst key =\n  'pk.eyJ1IjoiYWhvY2V2YXIiLCJhIjoiY2t0cGdwMHVnMGdlbzMxbDhwazBic2xrNSJ9.WbcTL9uj8JPAsnT9mgb7oQ';\n\nconst result = parseLiteralStyle({\n  'fill-color': ['get', 'fillColor'],\n  'stroke-color': ['get', 'strokeColor'],\n  'stroke-width': ['get', 'strokeWidth'],\n  symbol: {\n    symbolType: 'circle',\n    size: 8,\n    color: '#777',\n  },\n});\n\nclass WebGLVectorTileLayer extends VectorTile {\n  createRenderer() {\n    return new WebGLVectorTileLayerRenderer(this, {\n      style: {\n        fill: {\n          fragment: result.builder.getFillFragmentShader(),\n          vertex: result.builder.getFillVertexShader(),\n        },\n        stroke: {\n          fragment: result.builder.getStrokeFragmentShader(),\n          vertex: result.builder.getStrokeVertexShader(),\n        },\n        symbol: {\n          fragment: result.builder.getSymbolFragmentShader(),\n          vertex: result.builder.getSymbolVertexShader(),\n        },\n        attributes: {\n          fillColor: {\n            size: 2,\n            callback: (feature) => {\n              const style = this.getStyle()(feature, 1)[0];\n              const color = asArray(style?.getFill()?.getColor() || '#eee');\n              return packColor(color);\n            },\n          },\n          strokeColor: {\n            size: 2,\n            callback: (feature) => {\n              const style = this.getStyle()(feature, 1)[0];\n              const color = asArray(style?.getStroke()?.getColor() || '#eee');\n              return packColor(color);\n            },\n          },\n          strokeWidth: {\n            size: 1,\n            callback: (feature) => {\n              const style = this.getStyle()(feature, 1)[0];\n              return style?.getStroke()?.getWidth() || 0;\n            },\n          },\n        },\n      },\n    });\n  }\n}\n\nconst map = new Map({\n  layers: [\n    new WebGLVectorTileLayer({\n      source: new VectorTileSource({\n        attributions:\n          '© <a href=\"https://www.mapbox.com/map-feedback/\">Mapbox</a> ' +\n          '© <a href=\"https://www.openstreetmap.org/copyright\">' +\n          'OpenStreetMap contributors</a>',\n        format: new MVT(),\n        url:\n          'https://{a-d}.tiles.mapbox.com/v4/mapbox.mapbox-streets-v6/' +\n          '{z}/{x}/{y}.vector.pbf?access_token=' +\n          key,\n      }),\n      style: createMapboxStreetsV6Style(Style, Fill, Stroke, Icon, Text),\n    }),\n  ],\n  target: 'map',\n  view: new View({\n    center: [0, 0],\n    zoom: 2,\n  }),\n});\n"],"names":["TileGeometry","BaseTileRepresentation","constructor","options","styleRenderers","super","this","batch_","MixedGeometryBatch","styleRenderers_","buffers","setTile","tile","uploadTile","clear","sourceTiles","getSourceTiles","features","reduce","accumulator","sourceTile","concat","getFeatures","addFeatures","tileOriginX","extent","tileOriginY","transform","generatePromises","map","renderer","i","generateBuffers","then","Promise","all","setReady","WebGLVectorTileLayerRenderer","tileLayer","styles_","currentFrameStateTransform_","tmpTransform_","tmpMat4_","applyOptions_","reset","helper","createRenderers_","Array","isArray","style","VectorStyleRenderer","afterHelperCreated","createTileRepresentation","tileRep","listener","ready","getLayer","changed","removeEventListener","EventType","addEventListener","beforeTilesRender","frameState","tilesWithAlpha","makeProjectionTransform","applyUniforms_","alpha","renderExtent","batchInvertTransform","setUniformMatrixValue","mat4","setUniformFloatValue","setUniformFloatVec4","renderTile","tileRepresentation","tileTransform","tileResolution","tileSize","tileOrigin","tileExtent","depth","gutter","gutterExtent","ii","length","render","invertVerticesTransform","renderDeclutter","disposeInternal","result","symbol","symbolType","size","color","WebGLVectorTileLayer","VectorTile","createRenderer","fill","fragment","builder","getFillFragmentShader","vertex","getFillVertexShader","stroke","getStrokeFragmentShader","getStrokeVertexShader","getSymbolFragmentShader","getSymbolVertexShader","attributes","fillColor","callback","feature","getStyle","getFill","getColor","strokeColor","getStroke","strokeWidth","getWidth","Map","layers","source","attributions","format","MVT","url","createMapboxStreetsV6Style","Style","Fill","Stroke","Icon","Text","target","view","View","center","zoom"],"sourceRoot":""}