{"version":3,"file":"webgl-vector-layer.js","mappings":"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","sources":["webpack:///../src/ol/render/webgl/BatchRenderer.js","webpack:///../src/ol/render/webgl/LineStringBatchRenderer.js","webpack:///../src/ol/render/webgl/MixedGeometryBatch.js","webpack:///../src/ol/render/webgl/PointBatchRenderer.js","webpack:///../src/ol/render/webgl/PolygonBatchRenderer.js","webpack:///../src/ol/renderer/webgl/shaders.js","webpack:///../src/ol/renderer/webgl/VectorLayer.js","webpack:///./webgl-vector-layer.js"],"sourcesContent":["/**\n * @module ol/render/webgl/BatchRenderer\n */\nimport {WebGLWorkerMessageType} from './constants.js';\nimport {abstract} from '../../util.js';\nimport {\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  translate as translateTransform,\n} from '../../transform.js';\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default):number} callback This callback computes the numerical value of the\n * attribute for a given feature.\n */\n\nlet workerMessageCounter = 0;\n\n/**\n * @classdesc Abstract class for batch renderers.\n * Batch renderers are meant to render the geometries contained in a {@link module:ol/render/webgl/GeometryBatch}\n * instance. They are responsible for generating render instructions and transforming them into WebGL buffers.\n */\nclass AbstractBatchRenderer {\n  /**\n   * @param {import(\"../../webgl/Helper.js\").default} helper WebGL helper instance\n   * @param {Worker} worker WebGL worker instance\n   * @param {string} vertexShader Vertex shader\n   * @param {string} fragmentShader Fragment shader\n   * @param {Array<CustomAttribute>} customAttributes List of custom attributes\n   */\n  constructor(helper, worker, vertexShader, fragmentShader, customAttributes) {\n    /**\n     * @type {import(\"../../webgl/Helper.js\").default}\n     * @private\n     */\n    this.helper_ = helper;\n\n    /**\n     * @type {Worker}\n     * @private\n     */\n    this.worker_ = worker;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_ = this.helper_.getProgram(fragmentShader, vertexShader);\n\n    /**\n     * A list of attributes used by the renderer.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @protected\n     */\n    this.attributes = [];\n\n    /**\n     * @type {Array<CustomAttribute>}\n     * @protected\n     */\n    this.customAttributes = customAttributes;\n  }\n\n  /**\n   * Rebuild rendering instructions and webgl buffers based on the provided frame state\n   * Note: this is a costly operation.\n   * @param {import(\"./MixedGeometryBatch.js\").GeometryBatch} batch Geometry batch\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @param {import(\"../../geom/Geometry.js\").Type} geometryType Geometry type\n   * @param {function(): void} callback Function called once the render buffers are updated\n   */\n  rebuild(batch, frameState, geometryType, callback) {\n    // store transform for rendering instructions\n    batch.renderInstructionsTransform = this.helper_.makeProjectionTransform(\n      frameState,\n      createTransform()\n    );\n    this.generateRenderInstructions(batch);\n    this.generateBuffers_(batch, geometryType, callback);\n  }\n\n  /**\n   * Render the geometries in the batch. This will also update the current transform used for rendering according to\n   * the invert transform of the webgl buffers\n   * @param {import(\"./MixedGeometryBatch.js\").GeometryBatch} batch Geometry batch\n   * @param {import(\"../../transform.js\").Transform} currentTransform Transform\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} offsetX X offset\n   */\n  render(batch, currentTransform, frameState, offsetX) {\n    // multiply the current projection transform with the invert of the one used to fill buffers\n    this.helper_.makeProjectionTransform(frameState, currentTransform);\n    translateTransform(currentTransform, offsetX, 0);\n    multiplyTransform(currentTransform, batch.invertVerticesBufferTransform);\n\n    // enable program, buffers and attributes\n    this.helper_.useProgram(this.program_, frameState);\n    this.helper_.bindBuffer(batch.verticesBuffer);\n    this.helper_.bindBuffer(batch.indicesBuffer);\n    this.helper_.enableAttributes(this.attributes);\n\n    const renderCount = batch.indicesBuffer.getSize();\n    this.helper_.drawElements(0, renderCount);\n  }\n\n  /**\n   * Rebuild rendering instructions based on the provided frame state\n   * This is specific to the geometry type and has to be implemented by subclasses.\n   * @param {import(\"./MixedGeometryBatch.js\").GeometryBatch} batch Geometry batch\n   * @protected\n   */\n  generateRenderInstructions(batch) {\n    abstract();\n  }\n\n  /**\n   * Rebuild internal webgl buffers for rendering based on the current rendering instructions;\n   * This is asynchronous: webgl buffers wil _not_ be updated right away\n   * @param {import(\"./MixedGeometryBatch.js\").GeometryBatch} batch Geometry batch\n   * @param {import(\"../../geom/Geometry.js\").Type} geometryType Geometry type\n   * @param {function(): void} callback Function called once the render buffers are updated\n   * @private\n   */\n  generateBuffers_(batch, geometryType, callback) {\n    const messageId = workerMessageCounter++;\n\n    let messageType;\n    switch (geometryType) {\n      case 'Polygon':\n        messageType = WebGLWorkerMessageType.GENERATE_POLYGON_BUFFERS;\n        break;\n      case 'Point':\n        messageType = WebGLWorkerMessageType.GENERATE_POINT_BUFFERS;\n        break;\n      case 'LineString':\n        messageType = WebGLWorkerMessageType.GENERATE_LINE_STRING_BUFFERS;\n        break;\n      default:\n      // pass\n    }\n\n    /** @type {import('./constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: messageId,\n      type: messageType,\n      renderInstructions: batch.renderInstructions.buffer,\n      renderInstructionsTransform: batch.renderInstructionsTransform,\n      customAttributesCount: this.customAttributes.length,\n    };\n    this.worker_.postMessage(message, [batch.renderInstructions.buffer]);\n\n    // leave ownership of render instructions\n    batch.renderInstructions = null;\n\n    const handleMessage =\n      /**\n       * @param {*} event Event.\n       * @this {AbstractBatchRenderer}\n       */\n      function (event) {\n        const received = event.data;\n\n        // this is not the response to our request: skip\n        if (received.id !== messageId) {\n          return;\n        }\n\n        // we've received our response: stop listening\n        this.worker_.removeEventListener('message', handleMessage);\n\n        // store transform & invert transform for webgl buffers\n        batch.verticesBufferTransform = received.renderInstructionsTransform;\n        makeInverseTransform(\n          batch.invertVerticesBufferTransform,\n          batch.verticesBufferTransform\n        );\n\n        // copy & flush received buffers to GPU\n        batch.verticesBuffer.fromArrayBuffer(received.vertexBuffer);\n        this.helper_.flushBufferData(batch.verticesBuffer);\n        batch.indicesBuffer.fromArrayBuffer(received.indexBuffer);\n        this.helper_.flushBufferData(batch.indicesBuffer);\n\n        // take back ownership of the render instructions for further use\n        batch.renderInstructions = new Float32Array(\n          received.renderInstructions\n        );\n\n        callback();\n      }.bind(this);\n\n    this.worker_.addEventListener('message', handleMessage);\n  }\n}\n\nexport default AbstractBatchRenderer;\n","/**\n * @module ol/render/webgl/LineStringBatchRenderer\n */\nimport AbstractBatchRenderer from './BatchRenderer.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {transform2D} from '../../geom/flat/transform.js';\n\n/**\n * Names of attributes made available to the vertex shader.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const Attributes = {\n  SEGMENT_START: 'a_segmentStart',\n  SEGMENT_END: 'a_segmentEnd',\n  PARAMETERS: 'a_parameters',\n};\n\nclass LineStringBatchRenderer extends AbstractBatchRenderer {\n  /**\n   * @param {import(\"../../webgl/Helper.js\").default} helper WebGL helper instance\n   * @param {Worker} worker WebGL worker instance\n   * @param {string} vertexShader Vertex shader\n   * @param {string} fragmentShader Fragment shader\n   * @param {Array<import('./BatchRenderer.js').CustomAttribute>} customAttributes List of custom attributes\n   */\n  constructor(helper, worker, vertexShader, fragmentShader, customAttributes) {\n    super(helper, worker, vertexShader, fragmentShader, customAttributes);\n\n    // vertices for lines must hold both a position (x,y) and an offset (dx,dy)\n    this.attributes = [\n      {\n        name: Attributes.SEGMENT_START,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.SEGMENT_END,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.PARAMETERS,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(\n      customAttributes.map(function (attribute) {\n        return {\n          name: 'a_' + attribute.name,\n          size: 1,\n          type: AttributeType.FLOAT,\n        };\n      })\n    );\n  }\n\n  /**\n   * Render instructions for lines are structured like so:\n   * [ customAttr0, ... , customAttrN, numberOfVertices0, x0, y0, ... , xN, yN, numberOfVertices1, ... ]\n   * @param {import(\"./MixedGeometryBatch.js\").LineStringGeometryBatch} batch Linestring geometry batch\n   * @override\n   */\n  generateRenderInstructions(batch) {\n    // here we anticipate the amount of render instructions for lines:\n    // 2 instructions per vertex for position (x and y)\n    // + 1 instruction per line per custom attributes\n    // + 1 instruction per line (for vertices count)\n    const totalInstructionsCount =\n      2 * batch.verticesCount +\n      (1 + this.customAttributes.length) * batch.geometriesCount;\n    if (\n      !batch.renderInstructions ||\n      batch.renderInstructions.length !== totalInstructionsCount\n    ) {\n      batch.renderInstructions = new Float32Array(totalInstructionsCount);\n    }\n\n    // loop on features to fill the render instructions\n    let batchEntry;\n    const flatCoords = [];\n    let renderIndex = 0;\n    let value;\n    for (const featureUid in batch.entries) {\n      batchEntry = batch.entries[featureUid];\n      for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n        flatCoords.length = batchEntry.flatCoordss[i].length;\n        transform2D(\n          batchEntry.flatCoordss[i],\n          0,\n          flatCoords.length,\n          2,\n          batch.renderInstructionsTransform,\n          flatCoords\n        );\n\n        // custom attributes\n        for (let k = 0, kk = this.customAttributes.length; k < kk; k++) {\n          value = this.customAttributes[k].callback(batchEntry.feature);\n          batch.renderInstructions[renderIndex++] = value;\n        }\n\n        // vertices count\n        batch.renderInstructions[renderIndex++] = flatCoords.length / 2;\n\n        // looping on points for positions\n        for (let j = 0, jj = flatCoords.length; j < jj; j += 2) {\n          batch.renderInstructions[renderIndex++] = flatCoords[j];\n          batch.renderInstructions[renderIndex++] = flatCoords[j + 1];\n        }\n      }\n    }\n  }\n}\n\nexport default LineStringBatchRenderer;\n","/**\n * @module ol/render/webgl/MixedGeometryBatch\n */\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {create as createTransform} from '../../transform.js';\nimport {getUid} from '../../util.js';\n\n/**\n * @typedef {Object} GeometryBatchItem Object that holds a reference to a feature as well as the raw coordinates of its various geometries\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Array<Array<number>>} flatCoordss Array of flat coordinates arrays, one for each geometry related to the feature\n * @property {number} [verticesCount] Only defined for linestring and polygon batches\n * @property {number} [ringsCount] Only defined for polygon batches\n * @property {Array<Array<number>>} [ringsVerticesCounts] Array of vertices counts in each ring for each geometry; only defined for polygons batches\n */\n\n/**\n * @typedef {PointGeometryBatch|LineStringGeometryBatch|PolygonGeometryBatch} GeometryBatch\n */\n\n/**\n * @typedef {Object} PolygonGeometryBatch A geometry batch specific to polygons\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {Float32Array} renderInstructions Render instructions for polygons are structured like so:\n * [ numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, customAttr0, ..., xN, yN, customAttrN, numberOfRings,... ]\n * @property {WebGLArrayBuffer} verticesBuffer Vertices WebGL buffer\n * @property {WebGLArrayBuffer} indicesBuffer Indices WebGL buffer\n * @property {import(\"../../transform.js\").Transform} renderInstructionsTransform Converts world space coordinates to screen space; applies to the rendering instructions\n * @property {import(\"../../transform.js\").Transform} verticesBufferTransform Converts world space coordinates to screen space; applies to the webgl vertices buffer\n * @property {import(\"../../transform.js\").Transform} invertVerticesBufferTransform Screen space to world space; applies to the webgl vertices buffer\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n * @property {number} ringsCount How many outer and inner rings in this batch.\n */\n\n/**\n * @typedef {Object} LineStringGeometryBatch A geometry batch specific to lines\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {Float32Array} renderInstructions Render instructions for polygons are structured like so:\n * [ numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, customAttr0, ..., xN, yN, customAttrN, numberOfRings,... ]\n * @property {WebGLArrayBuffer} verticesBuffer Vertices WebGL buffer\n * @property {WebGLArrayBuffer} indicesBuffer Indices WebGL buffer\n * @property {import(\"../../transform.js\").Transform} renderInstructionsTransform Converts world space coordinates to screen space; applies to the rendering instructions\n * @property {import(\"../../transform.js\").Transform} verticesBufferTransform Converts world space coordinates to screen space; applies to the webgl vertices buffer\n * @property {import(\"../../transform.js\").Transform} invertVerticesBufferTransform Screen space to world space; applies to the webgl vertices buffer\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n */\n\n/**\n * @typedef {Object} PointGeometryBatch A geometry batch specific to points\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {Float32Array} renderInstructions Render instructions for polygons are structured like so:\n * [ numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, customAttr0, ..., xN, yN, customAttrN, numberOfRings,... ]\n * @property {WebGLArrayBuffer} verticesBuffer Vertices WebGL buffer\n * @property {WebGLArrayBuffer} indicesBuffer Indices WebGL buffer\n * @property {import(\"../../transform.js\").Transform} renderInstructionsTransform Converts world space coordinates to screen space; applies to the rendering instructions\n * @property {import(\"../../transform.js\").Transform} verticesBufferTransform Converts world space coordinates to screen space; applies to the webgl vertices buffer\n * @property {import(\"../../transform.js\").Transform} invertVerticesBufferTransform Screen space to world space; applies to the webgl vertices buffer\n */\n\n/**\n * @classdesc This class is used to group several geometries of various types together for faster rendering.\n * Three inner batches are maintained for polygons, lines and points. Each time a feature is added, changed or removed\n * from the batch, these inner batches are modified accordingly in order to keep them up-to-date.\n *\n * A feature can be present in several inner batches, for example a polygon geometry will be present in the polygon batch\n * and its linar rings will be present in the line batch. Multi geometries are also broken down into individual geometries\n * and added to the corresponding batches in a recursive manner.\n *\n * Corresponding {@link module:ol/render/webgl/BatchRenderer} instances are then used to generate the render instructions\n * and WebGL buffers (vertices and indices) for each inner batches; render instructions are stored on the inner batches,\n * alongside the transform used to convert world coords to screen coords at the time these instructions were generated.\n * The resulting WebGL buffers are stored on the batches as well.\n *\n * An important aspect of geometry batches is that there is no guarantee that render instructions and WebGL buffers\n * are synchronized, i.e. render instructions can describe a new state while WebGL buffers might not have been written yet.\n * This is why two world-to-screen transforms are stored on each batch: one for the render instructions and one for\n * the WebGL buffers.\n */\nclass MixedGeometryBatch {\n  constructor() {\n    /**\n     * @type {PolygonGeometryBatch}\n     */\n    this.polygonBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n      ringsCount: 0,\n      renderInstructions: new Float32Array(0),\n      verticesBuffer: new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW),\n      indicesBuffer: new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW),\n      renderInstructionsTransform: createTransform(),\n      verticesBufferTransform: createTransform(),\n      invertVerticesBufferTransform: createTransform(),\n    };\n\n    /**\n     * @type {PointGeometryBatch}\n     */\n    this.pointBatch = {\n      entries: {},\n      geometriesCount: 0,\n      renderInstructions: new Float32Array(0),\n      verticesBuffer: new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW),\n      indicesBuffer: new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW),\n      renderInstructionsTransform: createTransform(),\n      verticesBufferTransform: createTransform(),\n      invertVerticesBufferTransform: createTransform(),\n    };\n\n    /**\n     * @type {LineStringGeometryBatch}\n     */\n    this.lineStringBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n      renderInstructions: new Float32Array(0),\n      verticesBuffer: new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW),\n      indicesBuffer: new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW),\n      renderInstructionsTransform: createTransform(),\n      verticesBufferTransform: createTransform(),\n      invertVerticesBufferTransform: createTransform(),\n    };\n  }\n\n  /**\n   * @param {Array<import(\"../../Feature\").default>} features Array of features to add to the batch\n   */\n  addFeatures(features) {\n    for (let i = 0; i < features.length; i++) {\n      this.addFeature(features[i]);\n    }\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature to add to the batch\n   */\n  addFeature(feature) {\n    const geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @return {GeometryBatchItem} Batch item added (or existing one)\n   * @private\n   */\n  addFeatureEntryInPointBatch_(feature) {\n    const uid = getUid(feature);\n    if (!(uid in this.pointBatch.entries)) {\n      this.pointBatch.entries[uid] = {\n        feature: feature,\n        flatCoordss: [],\n      };\n    }\n    return this.pointBatch.entries[uid];\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @return {GeometryBatchItem} Batch item added (or existing one)\n   * @private\n   */\n  addFeatureEntryInLineStringBatch_(feature) {\n    const uid = getUid(feature);\n    if (!(uid in this.lineStringBatch.entries)) {\n      this.lineStringBatch.entries[uid] = {\n        feature: feature,\n        flatCoordss: [],\n        verticesCount: 0,\n      };\n    }\n    return this.lineStringBatch.entries[uid];\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @return {GeometryBatchItem} Batch item added (or existing one)\n   * @private\n   */\n  addFeatureEntryInPolygonBatch_(feature) {\n    const uid = getUid(feature);\n    if (!(uid in this.polygonBatch.entries)) {\n      this.polygonBatch.entries[uid] = {\n        feature: feature,\n        flatCoordss: [],\n        verticesCount: 0,\n        ringsCount: 0,\n        ringsVerticesCounts: [],\n      };\n    }\n    return this.polygonBatch.entries[uid];\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @private\n   */\n  clearFeatureEntryInPointBatch_(feature) {\n    const entry = this.pointBatch.entries[getUid(feature)];\n    if (!entry) {\n      return;\n    }\n    this.pointBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.pointBatch.entries[getUid(feature)];\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @private\n   */\n  clearFeatureEntryInLineStringBatch_(feature) {\n    const entry = this.lineStringBatch.entries[getUid(feature)];\n    if (!entry) {\n      return;\n    }\n    this.lineStringBatch.verticesCount -= entry.verticesCount;\n    this.lineStringBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.lineStringBatch.entries[getUid(feature)];\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @private\n   */\n  clearFeatureEntryInPolygonBatch_(feature) {\n    const entry = this.polygonBatch.entries[getUid(feature)];\n    if (!entry) {\n      return;\n    }\n    this.polygonBatch.verticesCount -= entry.verticesCount;\n    this.polygonBatch.ringsCount -= entry.ringsCount;\n    this.polygonBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.polygonBatch.entries[getUid(feature)];\n  }\n\n  /**\n   * @param {import(\"../../geom\").Geometry} geometry Geometry\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @private\n   */\n  addGeometry_(geometry, feature) {\n    const type = geometry.getType();\n    let flatCoords;\n    let verticesCount;\n    let batchEntry;\n    switch (type) {\n      case 'GeometryCollection':\n        /** @type {import(\"../../geom\").GeometryCollection} */ (geometry)\n          .getGeometries()\n          .map((geom) => this.addGeometry_(geom, feature));\n        break;\n      case 'MultiPolygon':\n        /** @type {import(\"../../geom\").MultiPolygon} */ (geometry)\n          .getPolygons()\n          .map((polygon) => this.addGeometry_(polygon, feature));\n        break;\n      case 'MultiLineString':\n        /** @type {import(\"../../geom\").MultiLineString} */ (geometry)\n          .getLineStrings()\n          .map((line) => this.addGeometry_(line, feature));\n        break;\n      case 'MultiPoint':\n        /** @type {import(\"../../geom\").MultiPoint} */ (geometry)\n          .getPoints()\n          .map((point) => this.addGeometry_(point, feature));\n        break;\n      case 'Polygon':\n        const polygonGeom = /** @type {import(\"../../geom\").Polygon} */ (\n          geometry\n        );\n        batchEntry = this.addFeatureEntryInPolygonBatch_(feature);\n        flatCoords = polygonGeom.getFlatCoordinates();\n        verticesCount = flatCoords.length / 2;\n        const ringsCount = polygonGeom.getLinearRingCount();\n        const ringsVerticesCount = polygonGeom\n          .getEnds()\n          .map((end, ind, arr) =>\n            ind > 0 ? (end - arr[ind - 1]) / 2 : end / 2\n          );\n        this.polygonBatch.verticesCount += verticesCount;\n        this.polygonBatch.ringsCount += ringsCount;\n        this.polygonBatch.geometriesCount++;\n        batchEntry.flatCoordss.push(flatCoords);\n        batchEntry.ringsVerticesCounts.push(ringsVerticesCount);\n        batchEntry.verticesCount += verticesCount;\n        batchEntry.ringsCount += ringsCount;\n        polygonGeom\n          .getLinearRings()\n          .map((ring) => this.addGeometry_(ring, feature));\n        break;\n      case 'Point':\n        const pointGeom = /** @type {import(\"../../geom\").Point} */ (geometry);\n        batchEntry = this.addFeatureEntryInPointBatch_(feature);\n        flatCoords = pointGeom.getFlatCoordinates();\n        this.pointBatch.geometriesCount++;\n        batchEntry.flatCoordss.push(flatCoords);\n        break;\n      case 'LineString':\n      case 'LinearRing':\n        const lineGeom = /** @type {import(\"../../geom\").LineString} */ (\n          geometry\n        );\n        batchEntry = this.addFeatureEntryInLineStringBatch_(feature);\n        flatCoords = lineGeom.getFlatCoordinates();\n        verticesCount = flatCoords.length / 2;\n        this.lineStringBatch.verticesCount += verticesCount;\n        this.lineStringBatch.geometriesCount++;\n        batchEntry.flatCoordss.push(flatCoords);\n        batchEntry.verticesCount += verticesCount;\n        break;\n      default:\n      // pass\n    }\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   */\n  changeFeature(feature) {\n    this.clearFeatureEntryInPointBatch_(feature);\n    this.clearFeatureEntryInPolygonBatch_(feature);\n    this.clearFeatureEntryInLineStringBatch_(feature);\n    const geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   */\n  removeFeature(feature) {\n    this.clearFeatureEntryInPointBatch_(feature);\n    this.clearFeatureEntryInPolygonBatch_(feature);\n    this.clearFeatureEntryInLineStringBatch_(feature);\n  }\n\n  clear() {\n    this.polygonBatch.entries = {};\n    this.polygonBatch.geometriesCount = 0;\n    this.polygonBatch.verticesCount = 0;\n    this.polygonBatch.ringsCount = 0;\n    this.lineStringBatch.entries = {};\n    this.lineStringBatch.geometriesCount = 0;\n    this.lineStringBatch.verticesCount = 0;\n    this.pointBatch.entries = {};\n    this.pointBatch.geometriesCount = 0;\n  }\n}\n\nexport default MixedGeometryBatch;\n","/**\n * @module ol/render/webgl/PointBatchRenderer\n */\n\nimport AbstractBatchRenderer from './BatchRenderer.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {apply as applyTransform} from '../../transform.js';\n\n/**\n * Names of attributes made available to the vertex shader.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const Attributes = {\n  POSITION: 'a_position',\n  INDEX: 'a_index',\n};\n\nclass PointBatchRenderer extends AbstractBatchRenderer {\n  /**\n   * @param {import(\"../../webgl/Helper.js\").default} helper WebGL helper instance\n   * @param {Worker} worker WebGL worker instance\n   * @param {string} vertexShader Vertex shader\n   * @param {string} fragmentShader Fragment shader\n   * @param {Array<import('./BatchRenderer.js').CustomAttribute>} customAttributes List of custom attributes\n   */\n  constructor(helper, worker, vertexShader, fragmentShader, customAttributes) {\n    super(helper, worker, vertexShader, fragmentShader, customAttributes);\n\n    // vertices for point must hold both a position (x,y) and an index (their position in the quad)\n    this.attributes = [\n      {\n        name: Attributes.POSITION,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.INDEX,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(\n      customAttributes.map(function (attribute) {\n        return {\n          name: 'a_' + attribute.name,\n          size: 1,\n          type: AttributeType.FLOAT,\n        };\n      })\n    );\n  }\n\n  /**\n   * Render instructions for lines are structured like so:\n   * [ x0, y0, customAttr0, ... , xN, yN, customAttrN ]\n   * @param {import(\"./MixedGeometryBatch.js\").PointGeometryBatch} batch Point geometry batch\n   * @override\n   */\n  generateRenderInstructions(batch) {\n    // here we anticipate the amount of render instructions for points:\n    // 2 instructions per vertex for position (x and y)\n    // + 1 instruction per vertex per custom attributes\n    const totalInstructionsCount =\n      (2 + this.customAttributes.length) * batch.geometriesCount;\n    if (\n      !batch.renderInstructions ||\n      batch.renderInstructions.length !== totalInstructionsCount\n    ) {\n      batch.renderInstructions = new Float32Array(totalInstructionsCount);\n    }\n\n    // loop on features to fill the render instructions\n    let batchEntry;\n    const tmpCoords = [];\n    let renderIndex = 0;\n    let value;\n    for (const featureUid in batch.entries) {\n      batchEntry = batch.entries[featureUid];\n      for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n        tmpCoords[0] = batchEntry.flatCoordss[i][0];\n        tmpCoords[1] = batchEntry.flatCoordss[i][1];\n        applyTransform(batch.renderInstructionsTransform, tmpCoords);\n\n        batch.renderInstructions[renderIndex++] = tmpCoords[0];\n        batch.renderInstructions[renderIndex++] = tmpCoords[1];\n\n        // pushing custom attributes\n        for (let j = 0, jj = this.customAttributes.length; j < jj; j++) {\n          value = this.customAttributes[j].callback(batchEntry.feature);\n          batch.renderInstructions[renderIndex++] = value;\n        }\n      }\n    }\n  }\n}\n\nexport default PointBatchRenderer;\n","/**\n * @module ol/render/webgl/PolygonBatchRenderer\n */\nimport AbstractBatchRenderer from './BatchRenderer.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {transform2D} from '../../geom/flat/transform.js';\n\n/**\n * Names of attributes made available to the vertex shader.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const Attributes = {\n  POSITION: 'a_position',\n};\n\nclass PolygonBatchRenderer extends AbstractBatchRenderer {\n  /**\n   * @param {import(\"../../webgl/Helper.js\").default} helper WebGL helper instance\n   * @param {Worker} worker WebGL worker instance\n   * @param {string} vertexShader Vertex shader\n   * @param {string} fragmentShader Fragment shader\n   * @param {Array<import('./BatchRenderer.js').CustomAttribute>} customAttributes List of custom attributes\n   */\n  constructor(helper, worker, vertexShader, fragmentShader, customAttributes) {\n    super(helper, worker, vertexShader, fragmentShader, customAttributes);\n\n    // By default only a position attribute is required to render polygons\n    this.attributes = [\n      {\n        name: Attributes.POSITION,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(\n      customAttributes.map(function (attribute) {\n        return {\n          name: 'a_' + attribute.name,\n          size: 1,\n          type: AttributeType.FLOAT,\n        };\n      })\n    );\n  }\n\n  /**\n   * Render instructions for polygons are structured like so:\n   * [ customAttr0, ..., customAttrN, numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, ..., xN, yN, numberOfRings,... ]\n   * @param {import(\"./MixedGeometryBatch.js\").PolygonGeometryBatch} batch Polygon geometry batch\n   * @override\n   */\n  generateRenderInstructions(batch) {\n    // here we anticipate the amount of render instructions for polygons:\n    // 2 instructions per vertex for position (x and y)\n    // + 1 instruction per polygon per custom attributes\n    // + 1 instruction per polygon (for vertices count in polygon)\n    // + 1 instruction per ring (for vertices count in ring)\n    const totalInstructionsCount =\n      2 * batch.verticesCount +\n      (1 + this.customAttributes.length) * batch.geometriesCount +\n      batch.ringsCount;\n    if (\n      !batch.renderInstructions ||\n      batch.renderInstructions.length !== totalInstructionsCount\n    ) {\n      batch.renderInstructions = new Float32Array(totalInstructionsCount);\n    }\n\n    // loop on features to fill the render instructions\n    let batchEntry;\n    const flatCoords = [];\n    let renderIndex = 0;\n    let value;\n    for (const featureUid in batch.entries) {\n      batchEntry = batch.entries[featureUid];\n      for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n        flatCoords.length = batchEntry.flatCoordss[i].length;\n        transform2D(\n          batchEntry.flatCoordss[i],\n          0,\n          flatCoords.length,\n          2,\n          batch.renderInstructionsTransform,\n          flatCoords\n        );\n\n        // custom attributes\n        for (let k = 0, kk = this.customAttributes.length; k < kk; k++) {\n          value = this.customAttributes[k].callback(batchEntry.feature);\n          batch.renderInstructions[renderIndex++] = value;\n        }\n\n        // ring count\n        batch.renderInstructions[renderIndex++] =\n          batchEntry.ringsVerticesCounts[i].length;\n\n        // vertices count in each ring\n        for (\n          let j = 0, jj = batchEntry.ringsVerticesCounts[i].length;\n          j < jj;\n          j++\n        ) {\n          batch.renderInstructions[renderIndex++] =\n            batchEntry.ringsVerticesCounts[i][j];\n        }\n\n        // looping on points for positions\n        for (let j = 0, jj = flatCoords.length; j < jj; j += 2) {\n          batch.renderInstructions[renderIndex++] = flatCoords[j];\n          batch.renderInstructions[renderIndex++] = flatCoords[j + 1];\n        }\n      }\n    }\n  }\n}\n\nexport default PolygonBatchRenderer;\n","/**\n * @module ol/renderer/webgl/shaders\n */\nimport {asArray} from '../../color.js';\n\n/** @typedef {'color'|'opacity'|'width'} DefaultAttributes */\n\n/**\n * Packs red/green/blue channels of a color into a single float value; alpha is ignored.\n * This is how the color is expected to be computed.\n * @param {import(\"../../color.js\").Color|string} color Color as array of numbers or string\n * @return {number} Float value containing the color\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256 * 256;\n  const g = array[1] * 256;\n  const b = array[2];\n  return r + g + b;\n}\n\nconst DECODE_COLOR_EXPRESSION = `vec3(\n  fract(floor(a_color / 256.0 / 256.0) / 256.0),\n  fract(floor(a_color / 256.0) / 256.0),\n  fract(a_color / 256.0)\n);`;\n\n/**\n * Default polygon vertex shader.\n * Relies on the color and opacity attributes.\n * @type {string}\n */\nexport const FILL_VERTEX_SHADER = `\n  precision mediump float;\n  uniform mat4 u_projectionMatrix;\n  attribute vec2 a_position;\n  attribute float a_color;\n  attribute float a_opacity;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n    gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n    v_color = ${DECODE_COLOR_EXPRESSION}\n    v_opacity = a_opacity;\n  }`;\n\n/**\n * Default polygon fragment shader.\n * @type {string}\n */\nexport const FILL_FRAGMENT_SHADER = `\n  precision mediump float;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n    gl_FragColor = vec4(v_color, 1.0) * v_opacity;\n  }`;\n\n/**\n * Default linestring vertex shader.\n * Relies on color, opacity and width attributes.\n * @type {string}\n */\nexport const STROKE_VERTEX_SHADER = `\n  precision mediump float;\n  uniform mat4 u_projectionMatrix;\n  uniform vec2 u_sizePx;\n  attribute vec2 a_segmentStart;\n  attribute vec2 a_segmentEnd;\n  attribute float a_parameters;\n  attribute float a_color;\n  attribute float a_opacity;\n  attribute float a_width;\n  varying vec2 v_segmentStart;\n  varying vec2 v_segmentEnd;\n  varying float v_angleStart;\n  varying float v_angleEnd;\n  varying vec3 v_color;\n  varying float v_opacity;\n  varying float v_width;\n\n  vec2 worldToPx(vec2 worldPos) {\n    vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\n    return (0.5 * screenPos.xy + 0.5) * u_sizePx;\n  }\n\n  vec4 pxToScreen(vec2 pxPos) {\n    vec2 screenPos = pxPos * 4.0 / u_sizePx;\n    return vec4(screenPos.xy, 0.0, 0.0);\n  }\n\n  vec2 getOffsetDirection(vec2 normalPx, vec2 tangentPx, float joinAngle) {\n    if (cos(joinAngle) > 0.93) return normalPx - tangentPx;\n    float halfAngle = joinAngle / 2.0;\n    vec2 angleBisectorNormal = vec2(\n      sin(halfAngle) * normalPx.x + cos(halfAngle) * normalPx.y,\n      -cos(halfAngle) * normalPx.x + sin(halfAngle) * normalPx.y\n    );\n    float length = 1.0 / sin(halfAngle);\n    return angleBisectorNormal * length;\n  }\n\n  void main(void) {\n    float anglePrecision = 1500.0;\n    float paramShift = 10000.0;\n    v_angleStart = fract(a_parameters / paramShift) * paramShift / anglePrecision;\n    v_angleEnd = fract(floor(a_parameters / paramShift + 0.5) / paramShift) * paramShift / anglePrecision;\n    float vertexNumber = floor(a_parameters / paramShift / paramShift + 0.0001);\n    vec2 tangentPx = worldToPx(a_segmentEnd) - worldToPx(a_segmentStart);\n    tangentPx = normalize(tangentPx);\n    vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);\n    float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;\n    float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;\n    float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;\n    vec2 offsetPx = getOffsetDirection(normalPx * normalDir, tangentDir * tangentPx, angle) * a_width * 0.5;\n    vec2 position =  vertexNumber < 1.5 ? a_segmentStart : a_segmentEnd;\n    gl_Position = u_projectionMatrix * vec4(position, 0.0, 1.0) + pxToScreen(offsetPx);\n    v_segmentStart = worldToPx(a_segmentStart);\n    v_segmentEnd = worldToPx(a_segmentEnd);\n    v_color = ${DECODE_COLOR_EXPRESSION}\n    v_opacity = a_opacity;\n    v_width = a_width;\n  }`;\n\n/**\n * Default linestring fragment shader.\n * @type {string}\n */\nexport const STROKE_FRAGMENT_SHADER = `\n  precision mediump float;\n  uniform float u_pixelRatio;\n  varying vec2 v_segmentStart;\n  varying vec2 v_segmentEnd;\n  varying float v_angleStart;\n  varying float v_angleEnd;\n  varying vec3 v_color;\n  varying float v_opacity;\n  varying float v_width;\n\n  float segmentDistanceField(vec2 point, vec2 start, vec2 end, float radius) {\n    vec2 startToPoint = point - start;\n    vec2 startToEnd = end - start;\n    float ratio = clamp(dot(startToPoint, startToEnd) / dot(startToEnd, startToEnd), 0.0, 1.0);\n    float dist = length(startToPoint - ratio * startToEnd);\n    return 1.0 - smoothstep(radius - 1.0, radius, dist);\n  }\n\n  void main(void) {\n    vec2 v_currentPoint = gl_FragCoord.xy / u_pixelRatio;\n    gl_FragColor = vec4(v_color, 1.0) * v_opacity;\n    gl_FragColor *= segmentDistanceField(v_currentPoint, v_segmentStart, v_segmentEnd, v_width);\n  }`;\n\n/**\n * Default point vertex shader.\n * Relies on color and opacity attributes.\n * @type {string}\n */\nexport const POINT_VERTEX_SHADER = `\n  precision mediump float;\n  uniform mat4 u_projectionMatrix;\n  uniform mat4 u_offsetScaleMatrix;\n  attribute vec2 a_position;\n  attribute float a_index;\n  attribute float a_color;\n  attribute float a_opacity;\n  varying vec2 v_texCoord;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n    mat4 offsetMatrix = u_offsetScaleMatrix;\n    float size = 6.0;\n    float offsetX = a_index == 0.0 || a_index == 3.0 ? -size / 2.0 : size / 2.0;\n    float offsetY = a_index == 0.0 || a_index == 1.0 ? -size / 2.0 : size / 2.0;\n    vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n    gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n    float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n    float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n    v_texCoord = vec2(u, v);\n    v_color = ${DECODE_COLOR_EXPRESSION}\n    v_opacity = a_opacity;\n  }`;\n\n/**\n * Default point fragment shader.\n * @type {string}\n */\nexport const POINT_FRAGMENT_SHADER = `\n  precision mediump float;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n      gl_FragColor = vec4(v_color, 1.0) * v_opacity;\n  }`;\n","/**\n * @module ol/renderer/webgl/VectorLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport LineStringBatchRenderer from '../../render/webgl/LineStringBatchRenderer.js';\nimport MixedGeometryBatch from '../../render/webgl/MixedGeometryBatch.js';\nimport PointBatchRenderer from '../../render/webgl/PointBatchRenderer.js';\nimport PolygonBatchRenderer from '../../render/webgl/PolygonBatchRenderer.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {DefaultUniform} from '../../webgl/Helper.js';\nimport {\n  FILL_FRAGMENT_SHADER,\n  FILL_VERTEX_SHADER,\n  POINT_FRAGMENT_SHADER,\n  POINT_VERTEX_SHADER,\n  STROKE_FRAGMENT_SHADER,\n  STROKE_VERTEX_SHADER,\n  packColor,\n} from './shaders.js';\nimport {buffer, createEmpty, equals, getWidth} from '../../extent.js';\nimport {create as createTransform} from '../../transform.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {listen, unlistenByKey} from '../../events.js';\n\n/**\n * @typedef {function(import(\"../../Feature\").default, Object<string, *>):number} CustomAttributeCallback A callback computing\n * the value of a custom attribute (different for each feature) to be passed on to the GPU.\n * Properties are available as 2nd arg for quicker access.\n */\n\n/**\n * @typedef {Object} ShaderProgram An object containing both shaders (vertex and fragment) as well as the required attributes\n * @property {string} [vertexShader] Vertex shader source (using the default one if unspecified).\n * @property {string} [fragmentShader] Fragment shader source (using the default one if unspecified).\n * @property {Object<import(\"./shaders.js\").DefaultAttributes,CustomAttributeCallback>} attributes Custom attributes made available in the vertex shader.\n * Keys are the names of the attributes which are then accessible in the vertex shader using the `a_` prefix, e.g.: `a_opacity`.\n * Default shaders rely on the attributes in {@link module:ol/render/webgl/shaders~DefaultAttributes}.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {ShaderProgram} [fill] Attributes and shaders for filling polygons.\n * @property {ShaderProgram} [stroke] Attributes and shaders for line strings and polygon strokes.\n * @property {ShaderProgram} [point] Attributes and shaders for points.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @param {Object<import(\"./shaders.js\").DefaultAttributes,CustomAttributeCallback>} obj Lookup of attribute getters.\n * @return {Array<import(\"../../render/webgl/BatchRenderer\").CustomAttribute>} An array of attribute descriptors.\n */\nfunction toAttributesArray(obj) {\n  return Object.keys(obj).map((key) => ({name: key, callback: obj[key]}));\n}\n\n/**\n * @classdesc\n * Experimental WebGL vector renderer. Supports polygons, lines and points:\n *  * Polygons are broken down into triangles\n *  * Lines are rendered as strips of quads\n *  * Points are rendered as quads\n *\n * You need to provide vertex and fragment shaders as well as custom attributes for each type of geometry. All shaders\n * can access the uniforms in the {@link module:ol/webgl/Helper~DefaultUniform} enum.\n * The vertex shaders can access the following attributes depending on the geometry type:\n *  * For polygons: {@link module:ol/render/webgl/PolygonBatchRenderer~Attributes}\n *  * For line strings: {@link module:ol/render/webgl/LineStringBatchRenderer~Attributes}\n *  * For points: {@link module:ol/render/webgl/PointBatchRenderer~Attributes}\n *\n * Please note that the fragment shaders output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Note: this uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n */\nclass WebGLVectorLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.sourceRevision_ = -1;\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    const fillAttributes = {\n      color: function () {\n        return packColor('#ddd');\n      },\n      opacity: function () {\n        return 1;\n      },\n      ...(options.fill && options.fill.attributes),\n    };\n\n    const strokeAttributes = {\n      color: function () {\n        return packColor('#eee');\n      },\n      opacity: function () {\n        return 1;\n      },\n      width: function () {\n        return 1.5;\n      },\n      ...(options.stroke && options.stroke.attributes),\n    };\n\n    const pointAttributes = {\n      color: function () {\n        return packColor('#eee');\n      },\n      opacity: function () {\n        return 1;\n      },\n      ...(options.point && options.point.attributes),\n    };\n\n    this.fillVertexShader_ =\n      (options.fill && options.fill.vertexShader) || FILL_VERTEX_SHADER;\n    this.fillFragmentShader_ =\n      (options.fill && options.fill.fragmentShader) || FILL_FRAGMENT_SHADER;\n    this.fillAttributes_ = toAttributesArray(fillAttributes);\n\n    this.strokeVertexShader_ =\n      (options.stroke && options.stroke.vertexShader) || STROKE_VERTEX_SHADER;\n    this.strokeFragmentShader_ =\n      (options.stroke && options.stroke.fragmentShader) ||\n      STROKE_FRAGMENT_SHADER;\n    this.strokeAttributes_ = toAttributesArray(strokeAttributes);\n\n    this.pointVertexShader_ =\n      (options.point && options.point.vertexShader) || POINT_VERTEX_SHADER;\n    this.pointFragmentShader_ =\n      (options.point && options.point.fragmentShader) || POINT_FRAGMENT_SHADER;\n    this.pointAttributes_ = toAttributesArray(pointAttributes);\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    /**\n     * @private\n     */\n    this.batch_ = new MixedGeometryBatch();\n\n    const source = this.getLayer().getSource();\n    this.batch_.addFeatures(source.getFeatures());\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this\n      ),\n    ];\n  }\n\n  afterHelperCreated() {\n    this.polygonRenderer_ = new PolygonBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.fillVertexShader_,\n      this.fillFragmentShader_,\n      this.fillAttributes_\n    );\n    this.pointRenderer_ = new PointBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.pointVertexShader_,\n      this.pointFragmentShader_,\n      this.pointAttributes_\n    );\n    this.lineStringRenderer_ = new LineStringBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.strokeVertexShader_,\n      this.strokeFragmentShader_,\n      this.strokeAttributes_\n    );\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.batch_.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.batch_.changeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    this.batch_.removeFeature(feature);\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.batch_.clear();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const projection = frameState.viewState.projection;\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const projectionExtent = projection.getExtent();\n    const extent = frameState.extent;\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n    let world = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n\n    do {\n      this.polygonRenderer_.render(\n        this.batch_.polygonBatch,\n        this.currentTransform_,\n        frameState,\n        world * worldWidth\n      );\n      this.lineStringRenderer_.render(\n        this.batch_.lineStringBatch,\n        this.currentTransform_,\n        frameState,\n        world * worldWidth\n      );\n      this.pointRenderer_.render(\n        this.batch_.pointBatch,\n        this.currentTransform_,\n        frameState,\n        world * worldWidth\n      );\n    } while (++world < endWorld);\n\n    this.helper.finalizeDraw(frameState);\n\n    const canvas = this.helper.getCanvas();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const opacity = layerState.opacity;\n    if (opacity !== parseFloat(canvas.style.opacity)) {\n      canvas.style.opacity = String(opacity);\n    }\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.ready = false;\n      let remaining = 3;\n      const rebuildCb = () => {\n        remaining--;\n        this.ready = remaining <= 0;\n        this.getLayer().changed();\n      };\n\n      this.polygonRenderer_.rebuild(\n        this.batch_.polygonBatch,\n        frameState,\n        'Polygon',\n        rebuildCb\n      );\n      this.lineStringRenderer_.rebuild(\n        this.batch_.lineStringBatch,\n        frameState,\n        'LineString',\n        rebuildCb\n      );\n      this.pointRenderer_.rebuild(\n        this.batch_.pointBatch,\n        frameState,\n        'Point',\n        rebuildCb\n      );\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n    this.helper.prepareDraw(frameState);\n\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLVectorLayerRenderer;\n","import GeoJSON from '../src/ol/format/GeoJSON.js';\nimport Layer from '../src/ol/layer/Layer.js';\nimport Map from '../src/ol/Map.js';\nimport OSM from '../src/ol/source/OSM.js';\nimport TileLayer from '../src/ol/layer/WebGLTile.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport View from '../src/ol/View.js';\nimport WebGLVectorLayerRenderer from '../src/ol/renderer/webgl/VectorLayer.js';\nimport {asArray} from '../src/ol/color.js';\nimport {packColor} from '../src/ol/renderer/webgl/shaders.js';\n\nclass WebGLLayer extends Layer {\n  createRenderer() {\n    return new WebGLVectorLayerRenderer(this, {\n      fill: {\n        attributes: {\n          color: function (feature) {\n            const color = asArray(feature.get('COLOR') || '#eee');\n            color[3] = 0.85;\n            return packColor(color);\n          },\n          opacity: function () {\n            return 0.6;\n          },\n        },\n      },\n      stroke: {\n        attributes: {\n          color: function (feature) {\n            const color = [...asArray(feature.get('COLOR') || '#eee')];\n            color.forEach((_, i) => (color[i] = Math.round(color[i] * 0.75))); // darken slightly\n            return packColor(color);\n          },\n          width: function () {\n            return 1.5;\n          },\n          opacity: function () {\n            return 1;\n          },\n        },\n      },\n    });\n  }\n}\n\nconst osm = new TileLayer({\n  source: new OSM(),\n});\n\nconst vectorLayer = new WebGLLayer({\n  source: new VectorSource({\n    url: 'https://openlayers.org/data/vector/ecoregions.json',\n    format: new GeoJSON(),\n  }),\n});\n\nconst map = new Map({\n  layers: [osm, vectorLayer],\n  target: 'map',\n  view: new View({\n    center: [0, 0],\n    zoom: 1,\n  }),\n});\n"],"names":["workerMessageCounter","constructor","helper","worker","vertexShader","fragmentShader","customAttributes","this","helper_","worker_","program_","getProgram","attributes","rebuild","batch","frameState","geometryType","callback","renderInstructionsTransform","makeProjectionTransform","createTransform","generateRenderInstructions","generateBuffers_","render","currentTransform","offsetX","translateTransform","multiplyTransform","invertVerticesBufferTransform","useProgram","bindBuffer","verticesBuffer","indicesBuffer","enableAttributes","renderCount","getSize","drawElements","abstract","messageId","messageType","WebGLWorkerMessageType","message","id","type","renderInstructions","buffer","customAttributesCount","length","postMessage","handleMessage","event","received","data","removeEventListener","verticesBufferTransform","makeInverseTransform","fromArrayBuffer","vertexBuffer","flushBufferData","indexBuffer","Float32Array","bind","addEventListener","Attributes","SEGMENT_START","SEGMENT_END","PARAMETERS","AbstractBatchRenderer","super","name","size","AttributeType","concat","map","attribute","totalInstructionsCount","verticesCount","geometriesCount","batchEntry","flatCoords","value","renderIndex","featureUid","entries","i","ii","flatCoordss","transform2D","k","kk","feature","j","jj","polygonBatch","ringsCount","WebGLArrayBuffer","ARRAY_BUFFER","DYNAMIC_DRAW","ELEMENT_ARRAY_BUFFER","pointBatch","lineStringBatch","addFeatures","features","addFeature","geometry","getGeometry","addGeometry_","addFeatureEntryInPointBatch_","uid","getUid","addFeatureEntryInLineStringBatch_","addFeatureEntryInPolygonBatch_","ringsVerticesCounts","clearFeatureEntryInPointBatch_","entry","clearFeatureEntryInLineStringBatch_","clearFeatureEntryInPolygonBatch_","getType","getGeometries","geom","getPolygons","polygon","getLineStrings","line","getPoints","point","polygonGeom","getFlatCoordinates","getLinearRingCount","ringsVerticesCount","getEnds","end","ind","arr","push","getLinearRings","ring","pointGeom","lineGeom","changeFeature","removeFeature","clear","POSITION","INDEX","tmpCoords","applyTransform","packColor","color","array","asArray","DECODE_COLOR_EXPRESSION","FILL_VERTEX_SHADER","STROKE_VERTEX_SHADER","POINT_VERTEX_SHADER","toAttributesArray","obj","Object","keys","key","WebGLVectorLayerRenderer","WebGLLayerRenderer","layer","options","uniforms","projectionMatrixTransform","DefaultUniform","postProcesses","sourceRevision_","previousExtent_","createEmpty","currentTransform_","fillAttributes","opacity","fill","strokeAttributes","width","stroke","pointAttributes","fillVertexShader_","fillFragmentShader_","fillAttributes_","strokeVertexShader_","strokeFragmentShader_","strokeAttributes_","pointVertexShader_","pointFragmentShader_","pointAttributes_","createWebGLWorker","batch_","MixedGeometryBatch","source","getLayer","getSource","getFeatures","sourceListenKeys_","listen","VectorEventType","handleSourceFeatureAdded_","handleSourceFeatureChanged_","handleSourceFeatureDelete_","handleSourceFeatureClear_","afterHelperCreated","polygonRenderer_","PolygonBatchRenderer","pointRenderer_","PointBatchRenderer","lineStringRenderer_","LineStringBatchRenderer","renderFrame","gl","getGL","preRender","vectorSource","projection","viewState","multiWorld","getWrapX","canWrapX","projectionExtent","getExtent","extent","worldWidth","getWidth","endWorld","Math","ceil","world","floor","finalizeDraw","canvas","getCanvas","layerStatesArray","layerIndex","parseFloat","style","String","postRender","prepareFrameInternal","viewNotMoving","viewHints","ViewHint","extentChanged","equals","sourceChanged","getRevision","resolution","renderBuffer","BaseVector","getRenderBuffer","loadFeatures","ready","remaining","rebuildCb","changed","slice","prepareDraw","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","disposeInternal","terminate","layer_","forEach","unlistenByKey","WebGLLayer","Layer","createRenderer","get","_","round","osm","TileLayer","OSM","vectorLayer","VectorSource","url","format","GeoJSON","Map","layers","target","view","View","center","zoom"],"sourceRoot":""}