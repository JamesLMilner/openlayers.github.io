{"version":3,"file":"webgl-vector-layer.js","mappings":"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","sources":["webpack:///../src/ol/renderer/webgl/VectorLayer.js","webpack:///./webgl-vector-layer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/VectorLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport MixedGeometryBatch from '../../render/webgl/MixedGeometryBatch.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport VectorStyleRenderer from '../../render/webgl/VectorStyleRenderer.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {DefaultUniform} from '../../webgl/Helper.js';\nimport {buffer, createEmpty, equals, getWidth} from '../../extent.js';\nimport {\n  create as createMat4,\n  fromTransform as mat4FromTransform,\n} from '../../vec/mat4.js';\nimport {\n  create as createTransform,\n  multiply as multiplyTransform,\n  setFromArray as setFromTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {listen, unlistenByKey} from '../../events.js';\n\nexport const Uniforms = {\n  ...DefaultUniform,\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  GLOBAL_ALPHA: 'u_globalAlpha',\n};\n\n/**\n * @typedef {import('../../render/webgl/VectorStyleRenderer.js').VectorStyle} VectorStyle\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {VectorStyle|Array<VectorStyle>} style Vector style as literal style or shaders; can also accept an array of styles\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Experimental WebGL vector renderer. Supports polygons, lines and points:\n *  * Polygons are broken down into triangles\n *  * Lines are rendered as strips of quads\n *  * Points are rendered as quads\n *\n * You need to provide vertex and fragment shaders as well as custom attributes for each type of geometry. All shaders\n * can access the uniforms in the {@link module:ol/webgl/Helper~DefaultUniform} enum.\n * The vertex shaders can access the following attributes depending on the geometry type:\n *  * For polygons: {@link module:ol/render/webgl/PolygonBatchRenderer~Attributes}\n *  * For line strings: {@link module:ol/render/webgl/LineStringBatchRenderer~Attributes}\n *  * For points: {@link module:ol/render/webgl/PointBatchRenderer~Attributes}\n *\n * Please note that the fragment shaders output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Note: this uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n */\nclass WebGLVectorLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = {\n      [Uniforms.RENDER_EXTENT]: [0, 0, 0, 0],\n      [Uniforms.GLOBAL_ALPHA]: 1,\n    };\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.sourceRevision_ = -1;\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = createTransform();\n\n    this.tmpTransform_ = createTransform();\n    this.tmpMat4_ = createMat4();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentFrameStateTransform_ = createTransform();\n\n    /**\n     * @type {Array<VectorStyle>}\n     * @private\n     */\n    this.styles_ = [];\n\n    /**\n     * @type {Array<VectorStyleRenderer>}\n     * @private\n     */\n    this.styleRenderers_ = [];\n\n    /**\n     * @type {Array<import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers>}\n     * @private\n     */\n    this.buffers_ = [];\n\n    this.applyOptions_(options);\n\n    /**\n     * @private\n     */\n    this.batch_ = new MixedGeometryBatch();\n\n    const source = this.getLayer().getSource();\n    this.batch_.addFeatures(source.getFeatures());\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this\n      ),\n    ];\n  }\n\n  /**\n   * @param {Options} options Options.\n   * @private\n   */\n  applyOptions_(options) {\n    this.styles_ = Array.isArray(options.style)\n      ? options.style\n      : [options.style];\n  }\n\n  /**\n   * @private\n   */\n  createRenderers_() {\n    this.buffers_ = [];\n    this.styleRenderers_ = this.styles_.map(\n      (style) => new VectorStyleRenderer(style, this.helper)\n    );\n  }\n\n  reset(options) {\n    this.applyOptions_(options);\n    if (this.helper) {\n      this.createRenderers_();\n    }\n    super.reset(options);\n  }\n\n  afterHelperCreated() {\n    this.createRenderers_();\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.batch_.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.batch_.changeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    this.batch_.removeFeature(feature);\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.batch_.clear();\n  }\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} batchInvertTransform Inverse of the transformation in which geometries are expressed\n   * @private\n   */\n  applyUniforms_(batchInvertTransform) {\n    // world to screen matrix\n    setFromTransform(this.tmpTransform_, this.currentFrameStateTransform_);\n    multiplyTransform(this.tmpTransform_, batchInvertTransform);\n    this.helper.setUniformMatrixValue(\n      Uniforms.PROJECTION_MATRIX,\n      mat4FromTransform(this.tmpMat4_, this.tmpTransform_)\n    );\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    this.helper.prepareDraw(frameState);\n    this.currentFrameStateTransform_ = this.helper.makeProjectionTransform(\n      frameState,\n      this.currentFrameStateTransform_\n    );\n\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const projection = frameState.viewState.projection;\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const projectionExtent = projection.getExtent();\n    const extent = frameState.extent;\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n    let world = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n\n    translateTransform(this.currentFrameStateTransform_, world * worldWidth, 0);\n    do {\n      for (let i = 0, ii = this.styleRenderers_.length; i < ii; i++) {\n        const renderer = this.styleRenderers_[i];\n        const buffers = this.buffers_[i];\n        if (!buffers) {\n          continue;\n        }\n        renderer.render(buffers, frameState, () => {\n          this.applyUniforms_(buffers.invertVerticesTransform);\n        });\n      }\n      translateTransform(this.currentFrameStateTransform_, worldWidth, 0);\n    } while (++world < endWorld);\n\n    this.helper.finalizeDraw(frameState);\n\n    const canvas = this.helper.getCanvas();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const opacity = layerState.opacity;\n    if (opacity !== parseFloat(canvas.style.opacity)) {\n      canvas.style.opacity = String(opacity);\n    }\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.ready = false;\n\n      const transform = this.helper.makeProjectionTransform(\n        frameState,\n        createTransform()\n      );\n\n      const generatePromises = this.styleRenderers_.map((renderer, i) =>\n        renderer.generateBuffers(this.batch_, transform).then((buffers) => {\n          this.buffers_[i] = buffers;\n        })\n      );\n      Promise.all(generatePromises).then(() => {\n        this.ready = true;\n        this.getLayer().changed();\n      });\n\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLVectorLayerRenderer;\n","import GeoJSON from '../src/ol/format/GeoJSON.js';\nimport Layer from '../src/ol/layer/Layer.js';\nimport Map from '../src/ol/Map.js';\nimport OSM from '../src/ol/source/OSM.js';\nimport TileLayer from '../src/ol/layer/WebGLTile.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport View from '../src/ol/View.js';\nimport WebGLVectorLayerRenderer from '../src/ol/renderer/webgl/VectorLayer.js';\n\n/** @type {import('../src/ol/style/literal.js').LiteralStyle} */\nconst style = {\n  'stroke-color': ['*', ['get', 'COLOR'], [220, 220, 220]],\n  'stroke-width': 1.5,\n  'fill-color': ['*', ['get', 'COLOR'], [255, 255, 255, 0.6]],\n};\n\nclass WebGLLayer extends Layer {\n  createRenderer() {\n    return new WebGLVectorLayerRenderer(this, {\n      style,\n    });\n  }\n}\n\nconst osm = new TileLayer({\n  source: new OSM(),\n});\n\nconst vectorLayer = new WebGLLayer({\n  source: new VectorSource({\n    url: 'https://openlayers.org/data/vector/ecoregions.json',\n    format: new GeoJSON(),\n  }),\n});\n\nconst map = new Map({\n  layers: [osm, vectorLayer],\n  target: 'map',\n  view: new View({\n    center: [0, 0],\n    zoom: 1,\n  }),\n});\n"],"names":["Uniforms","RENDER_EXTENT","GLOBAL_ALPHA","WebGLVectorLayerRenderer","constructor","layer","options","super","uniforms","postProcesses","this","sourceRevision_","previousExtent_","currentTransform_","tmpTransform_","tmpMat4_","currentFrameStateTransform_","styles_","styleRenderers_","buffers_","applyOptions_","batch_","MixedGeometryBatch","source","getLayer","getSource","addFeatures","getFeatures","sourceListenKeys_","VectorEventType","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","Array","isArray","style","createRenderers_","map","VectorStyleRenderer","helper","reset","afterHelperCreated","event","feature","addFeature","changeFeature","removeFeature","clear","applyUniforms_","batchInvertTransform","setUniformMatrixValue","PROJECTION_MATRIX","mat4","renderFrame","frameState","gl","getGL","preRender","prepareDraw","makeProjectionTransform","vectorSource","projection","viewState","multiWorld","getWrapX","canWrapX","projectionExtent","getExtent","extent","worldWidth","endWorld","Math","ceil","world","floor","i","ii","length","renderer","buffers","render","invertVerticesTransform","finalizeDraw","canvas","getCanvas","opacity","layerStatesArray","layerIndex","parseFloat","String","postRender","prepareFrameInternal","viewNotMoving","viewHints","ViewHint","ANIMATING","INTERACTING","extentChanged","sourceChanged","getRevision","resolution","renderBuffer","BaseVector","getRenderBuffer","loadFeatures","ready","transform","generatePromises","generateBuffers","then","Promise","all","changed","slice","forEachFeatureAtCoordinate","coordinate","hitTolerance","callback","matches","disposeInternal","forEach","key","WebGLLayer","Layer","createRenderer","osm","OSM","vectorLayer","Vector","url","format","GeoJSON","Map","layers","target","view","View","center","zoom"],"sourceRoot":""}